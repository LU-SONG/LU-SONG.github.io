<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Notes of Linux</title>
    <url>/2024/05/15/notes-of-linux/</url>
    <content><![CDATA[<p><strong><font size=6>Linux 基础</font></strong></p>
<h1 id="一、Linux-常用命令"><a href="#一、Linux-常用命令" class="headerlink" title="一、Linux 常用命令"></a>一、Linux 常用命令</h1><h3 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h3><ul>
<li>ssh 远程连接</li>
<li>cd 切换目录</li>
<li>ls 查看目录列表</li>
<li>tree 打印目录树</li>
<li>mkdir 创建目录</li>
<li>rm 删除目录</li>
<li>touch 新建文件</li>
<li>cp 复制文件</li>
<li>mv 移动文件</li>
<li>find 搜索文件</li>
<li>grep &#x2F; sed &#x2F; awk 文本处理</li>
</ul>
<h3 id="文件、路径操作"><a href="#文件、路径操作" class="headerlink" title="文件、路径操作"></a>文件、路径操作</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取当前目录</span></span><br><span class="line">current_directory=$(<span class="built_in">pwd</span>)    <span class="comment"># Linux</span></span><br><span class="line">current_directory = os.getcwd()    <span class="comment"># Python</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件、目录、删除、重命名</span></span><br><span class="line"><span class="built_in">touch</span> file.txt ; <span class="built_in">mkdir</span> <span class="built_in">dir</span></span><br><span class="line"><span class="built_in">rm</span> file.txt ; <span class="built_in">rm</span> -r <span class="built_in">dir</span></span><br><span class="line"><span class="built_in">mv</span> old_name new_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件</span></span><br><span class="line"><span class="built_in">cat</span> file.txt</span><br><span class="line"><span class="built_in">cat</span> file.txt | grep <span class="string">&quot;keyword&quot;</span></span><br><span class="line"><span class="built_in">head</span> -n 10 file.txt ; <span class="built_in">tail</span> -n 10 file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找，find+路径+-name+匹配文件名</span></span><br><span class="line">find . -name *.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找，grep+字符+文件路径，显示第一行</span></span><br><span class="line">grep LOOP OUTCAR | <span class="built_in">head</span> -n 1</span><br></pre></td></tr></table></figure>

<h3 id="批量替换常用关键参数，sed-i-‘s-模式-替换-‘-file"><a href="#批量替换常用关键参数，sed-i-‘s-模式-替换-‘-file" class="headerlink" title="批量替换常用关键参数，sed -i ‘s&#x2F;模式&#x2F;替换&#x2F;‘ file"></a>批量替换常用关键参数，sed -i ‘s&#x2F;模式&#x2F;替换&#x2F;‘ file</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sed -i 表示原地编辑不在终端输出，&#x27;.*&#x27;表示任意字符重复零次或多次，</span></span><br><span class="line"><span class="comment"># \(.*\): 捕获从行首到第一个出现的 F F F 之前的所有字符，并将其存储在第一个捕获组 \1 中。</span></span><br><span class="line">sed -i <span class="string">&#x27;s/IBRION =.*/IBRION = 2/&#x27;</span>  */INCAR</span><br><span class="line">sed -i <span class="string">&#x27;s/NCORE =.*/NCORE = 12/&#x27;</span>  */INCAR</span><br><span class="line">sed -i <span class="string">&#x27;s/^\(.*\)F   F   F\(.*\)$/\1F   F   T\2/&#x27;</span> */POSCAR</span><br></pre></td></tr></table></figure>

<h3 id="文件压缩、解压"><a href="#文件压缩、解压" class="headerlink" title="文件压缩、解压"></a>文件压缩、解压</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -z: 使用 gzip 解压缩归档文件; -c/x: 打包/提取归档文件;-v: 显示详细信息，处理文件时显示文件名（可选）;-f: 指定归档文件的名称</span></span><br><span class="line">tar -zcvf file.tar.gz file.txt <span class="comment"># 压缩</span></span><br><span class="line">tar -zxvf file.tar <span class="comment">#解压缩</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -r: 递归处理</span></span><br><span class="line">zip -r html.zip /home/html</span><br><span class="line">unzip html.zip</span><br></pre></td></tr></table></figure>
<h3 id="磁盘管理，文件数量"><a href="#磁盘管理，文件数量" class="headerlink" title="磁盘管理，文件数量"></a>磁盘管理，文件数量</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -h：使用 KB、MB、GB 等单位输出</span></span><br><span class="line"><span class="comment"># 查看文件系统整体磁盘使用情况 </span></span><br><span class="line"><span class="built_in">df</span> -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目录所占磁盘空间</span></span><br><span class="line"><span class="built_in">du</span> -h ./test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前目录下文件数量，wc --l 统计行数</span></span><br><span class="line"><span class="built_in">ls</span> -l | grep <span class="string">&#x27;^-r&#x27;</span> | <span class="built_in">wc</span> --l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前目录下目录数量，wc --l 统计行数</span></span><br><span class="line"><span class="built_in">ls</span> -l | grep <span class="string">&#x27;^d&#x27;</span> | <span class="built_in">wc</span> --l</span><br></pre></td></tr></table></figure>
<h3 id="文件权限操作（change-mode）"><a href="#文件权限操作（change-mode）" class="headerlink" title="文件权限操作（change mode）"></a>文件权限操作（change mode）</h3><p>Linux&#x2F;Unix 的文件调用权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users）<br><img src="/images/Linux_notes-image.png" alt="chmod"><br>只有文件所有者和超级用户可以修改文件或目录的权限。可以使用绝对模式（八进制数字模式），符号模式指定文件的权限。<br><img src="/images/Linux_notes-image-1.png" alt="limit"><br>改变权限：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 644 file.txt</span><br><span class="line"><span class="built_in">chmod</span> 777 file.txt   </span><br><span class="line"><span class="built_in">chmod</span> +rwx file.txt</span><br><span class="line"><span class="built_in">chown</span> user file.txt <span class="comment"># 改变文件所有者</span></span><br></pre></td></tr></table></figure>

<h3 id="获取当前目录下的所有子目录"><a href="#获取当前目录下的所有子目录" class="headerlink" title="获取当前目录下的所有子目录"></a>获取当前目录下的所有子目录</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找所有一级子目录，-maxdepth 1 表示只查找一级子目录，! -name &#x27;.&#x27; 表示排除当前目录</span></span><br><span class="line">find . -maxdepth 1 -<span class="built_in">type</span> d ! -name <span class="string">&#x27;.&#x27;</span></span><br><span class="line"><span class="comment"># 查找所有一级子目录</span></span><br><span class="line"><span class="built_in">ls</span> -d */ </span><br></pre></td></tr></table></figure>

<h3 id="读取输入内容"><a href="#读取输入内容" class="headerlink" title="读取输入内容"></a>读取输入内容</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">read</span> Value	<span class="comment">#Linux</span></span><br><span class="line">Value = input(<span class="string">&quot;&quot;</span>)  <span class="comment">#Python</span></span><br></pre></td></tr></table></figure>



<h2 id="二、Linux-目录结构"><a href="#二、Linux-目录结构" class="headerlink" title="二、Linux 目录结构"></a>二、Linux 目录结构</h2><h3 id="文件系统层次结构标准"><a href="#文件系统层次结构标准" class="headerlink" title="文件系统层次结构标准"></a>文件系统层次结构标准</h3><p>Filesystem Hierarchy Standard</p>
<ol>
<li><a href="https://blog.csdn.net/Ph_Nirvana/article/details/62427684">https://blog.csdn.net/Ph_Nirvana/article/details/62427684</a></li>
<li><a href="https://blog.csdn.net/m0_38044196/article/details/72844025">https://blog.csdn.net/m0_38044196/article/details/72844025</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E6%A0%87%E5%87%86">文件系统层次结构标准 - 维基百科，自由的百科全书 (wikipedia.org)</a></li>
</ol>
<table>
<thead>
<tr>
<th align="center">目录</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x2F;</td>
<td align="center">整个文件系统层次结构的根目录</td>
</tr>
<tr>
<td align="center">&#x2F;bin&#x2F;</td>
<td align="center">需要在单用户模式可用的可执行文件</td>
</tr>
<tr>
<td align="center">&#x2F;boot&#x2F;</td>
<td align="center">引导程序文件</td>
</tr>
<tr>
<td align="center">&#x2F;dev&#x2F;</td>
<td align="center">必要设备</td>
</tr>
<tr>
<td align="center">&#x2F;etc&#x2F;</td>
<td align="center">特定主机，系统范围内的配置文件</td>
</tr>
<tr>
<td align="center">&#x2F;home&#x2F;</td>
<td align="center">用户的家目录，包含保存的文件、个人设置等，一般为单独的分区</td>
</tr>
<tr>
<td align="center">&#x2F;lib&#x2F;</td>
<td align="center">&#x2F;bin&#x2F; 和 &#x2F;sbin&#x2F;中二进制文件必要的库文件</td>
</tr>
<tr>
<td align="center">&#x2F;mnt&#x2F;</td>
<td align="center">临时挂载的文件系统</td>
</tr>
<tr>
<td align="center">&#x2F;opt&#x2F;</td>
<td align="center">可选应用软件包</td>
</tr>
<tr>
<td align="center">&#x2F;proc&#x2F;</td>
<td align="center">虚拟文件系统，将内核与进程状态归档为文本文件。例如：uptime、 network。在Linux中，对应Procfs格式挂载</td>
</tr>
<tr>
<td align="center">&#x2F;root&#x2F;</td>
<td align="center">超级用户的家目录</td>
</tr>
<tr>
<td align="center">&#x2F;sbin&#x2F;</td>
<td align="center">必要的系统二进制文件，例如： init、 ip、 mount</td>
</tr>
<tr>
<td align="center">&#x2F;tmp&#x2F;</td>
<td align="center">临时文件(参见 &#x2F;var&#x2F;tmp)，在系统重启时目录中文件不会被保留</td>
</tr>
<tr>
<td align="center">&#x2F;usr&#x2F;</td>
<td align="center">用于存储只读用户数据的第二层次</td>
</tr>
<tr>
<td align="center">&#x2F;var&#x2F;</td>
<td align="center">变量文件——在正常运行的系统中其内容不断变化的文件，如日志，脱机文件和临时电子邮件文件。</td>
</tr>
</tbody></table>
<h2 id="二、服务器管理"><a href="#二、服务器管理" class="headerlink" title="二、服务器管理"></a>二、服务器管理</h2><h3 id="管理常用命令"><a href="#管理常用命令" class="headerlink" title="管理常用命令"></a>管理常用命令</h3><ul>
<li>cat &#x2F;proc&#x2F;cpuinfo 查看 CPU 信息</li>
<li>top 查看系统使用情况</li>
<li>df 查看磁盘使用情况</li>
<li>free 显示系统内存情况</li>
<li>sudo 以管理员身份执行</li>
<li>whereis 查看可执行文件路径</li>
<li>chmod 设置目录权限</li>
<li>cat &#x2F; more &#x2F; less 查看文件</li>
<li>zip &#x2F; tar &#x2F; gzip 压缩文件</li>
<li>unzip &#x2F; tar &#x2F; gunzip 解压文件</li>
<li>crontab 计划任务</li>
<li>nohup 后台运行程序</li>
<li>ps 查看进程</li>
<li>kill 杀死进程</li>
<li>rpm &#x2F; yum &#x2F; apt &#x2F; apt-get &#x2F; dpkg 软件包管理</li>
<li>service &#x2F; systemctl 服务管理</li>
<li>ifconfig 查看网络属性</li>
<li>netstat 查看网络状态</li>
<li>date 显示系统时间</li>
<li>rpm 安装用 RPM 来打包的软件</li>
<li>yum 基于 rpm 的软件包管理器，能够从指定的服务器自动下载 RPM 包并且安装</li>
</ul>
<h3 id="超线程"><a href="#超线程" class="headerlink" title="超线程"></a>超线程</h3><p><a href="http://sobereva.com/392">http://sobereva.com/392</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://www.runoob.com/linux">https://www.runoob.com/linux</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Bader View of VASP</title>
    <url>/2024/06/03/bader-view-of-vasp/</url>
    <content><![CDATA[<p><strong><font size=6>Bader View of VASP</font></strong></p>
<p>本教程基于 HPC of zhenggroup 集群环境</p>
<h2 id="Bader-计算过程"><a href="#Bader-计算过程" class="headerlink" title="Bader 计算过程"></a>Bader 计算过程</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">LAECHG=.TRUE. </span><br><span class="line">LCHARG = .TRUE.</span><br><span class="line">NSW = 0</span><br></pre></td></tr></table></figure>
<p>得到CHGCAR文件</p>
<h2 id="计算结果分析"><a href="#计算结果分析" class="headerlink" title="计算结果分析"></a>计算结果分析</h2><h3 id="数值分析"><a href="#数值分析" class="headerlink" title="数值分析"></a>数值分析</h3><ol>
<li><code>bader.sh</code>分析CHGCAR文件得到<code>ACF.dat</code><br>其中 ACF.dat 文件包含：原子坐标和每个原子的价层电子数目，通过对比价电子数和 POTCAR 中的 ZVAL 就能得到每个原子的 bader 电荷</li>
<li><code>grep ZVAL POTCAR</code>得到元素的价电子(vaspkit手册中，刘锦程提到进行 Bader 电荷分析，可采用带 _pv,_sv 的赝势)</li>
</ol>
<h3 id="可视化分析"><a href="#可视化分析" class="headerlink" title="可视化分析"></a>可视化分析</h3><ol>
<li><p><code>python bader2pqr.py</code>得到<code>bader.pqr</code>,<code>get_lattice.exe</code>得到<code>vmdrc.txt</code></p>
</li>
<li><p>打开vmd，将bader.pqr拖入窗口，<code>vmdrc.txt</code>的命令行逐行输入到终端，可修改颜色范围<br><img src="/img/Bader-view-of-VASP-4fb526d3fb4d86c020ee682e14d650f.png" alt="vmd使用"></p>
</li>
<li><p>高分辨率设置<br>display-rendermode-GLSL<br>file-render-tachyon (internal)<br>显示窗口最大化</p>
</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://www.vasp.org/howto">VASP 官网</a></li>
<li><a href="https://www.bigbrosci.com/">Learn VASP The Hard Way</a></li>
</ol>
]]></content>
      <categories>
        <category>DFT</category>
      </categories>
      <tags>
        <tag>vasp</tag>
        <tag>bader</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes of Python</title>
    <url>/2024/05/15/notes-of-python/</url>
    <content><![CDATA[<p><strong><font size=6>Python 常用命令（一）</font></strong></p>
<h2 id="一、内置函数"><a href="#一、内置函数" class="headerlink" title="一、内置函数"></a>一、内置函数</h2><h3 id="字符串相关（数）"><a href="#字符串相关（数）" class="headerlink" title="字符串相关（数）"></a>字符串相关（数）</h3><table>
<thead>
<tr>
<th>需求</th>
<th>输入</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>计算字符串长度</td>
<td>len(“Hello, Python!”)</td>
<td>14</td>
</tr>
<tr>
<td>str1 &#x3D; ‘aaBBccEEff’ 统计字符串中指定字符出现的次数（指定范围）</td>
<td>str1.count(“a”, 0, 3)</td>
<td>2</td>
</tr>
<tr>
<td>查找字符串中指定的字符第一次出现的索引（指定范围），不会触发异常（返回-1）</td>
<td>str1.find(“d”, 3)</td>
<td>-1</td>
</tr>
<tr>
<td>查找~，会触发异常</td>
<td>str1.index(“c”, 3)</td>
<td>4</td>
</tr>
<tr>
<td>二进制 → 十进制</td>
<td>int(‘101010’,2)</td>
<td>42</td>
</tr>
<tr>
<td>八进制 → 十进制</td>
<td>int(‘367’,8)</td>
<td>247</td>
</tr>
<tr>
<td>十六进制 → 十进制</td>
<td>int(‘FFF’,16)</td>
<td>4095</td>
</tr>
</tbody></table>
<h3 id="字符串相关（字符型）"><a href="#字符串相关（字符型）" class="headerlink" title="字符串相关（字符型）"></a>字符串相关（字符型）</h3><table>
<thead>
<tr>
<th>需求</th>
<th>输入</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>str1 &#x3D; ‘aaBBccEEff’ 全部转换为小写字符</td>
<td>str1.lower()</td>
<td>‘aabbcceeff’</td>
</tr>
<tr>
<td>全部转换为大写字符</td>
<td>str1.upper()</td>
<td>‘AABBCCEEFF’</td>
</tr>
<tr>
<td>将字符串中的字符替换为指定的字符</td>
<td>str1.replace(“a”, “W”, 1)</td>
<td>‘WaBBccEEff’</td>
</tr>
<tr>
<td>test1 &#x3D; “  abc  “删除字符串两边的所有空白</td>
<td>test1.strip()</td>
<td>‘abc’</td>
</tr>
<tr>
<td>删除字符串指定字符</td>
<td>test1.strip().strip(“a”)</td>
<td>‘bc’</td>
</tr>
</tbody></table>
<h3 id="字符串相关（布尔型）"><a href="#字符串相关（布尔型）" class="headerlink" title="字符串相关（布尔型）"></a>字符串相关（布尔型）</h3><table>
<thead>
<tr>
<th>需求</th>
<th>输入</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>判断字符串是否以指定字符开头（指定范围）</td>
<td>str1.startswith(“a”)</td>
<td>True</td>
</tr>
<tr>
<td>判断字符串是否以指定字符结尾（指定范围）</td>
<td>str1.endswith(“b”, 0, 2)</td>
<td>False</td>
</tr>
<tr>
<td>input_str &#x3D; ‘123’ 识别整数</td>
<td>input_str.isdigit()</td>
<td>True</td>
</tr>
<tr>
<td>识别字母</td>
<td>input_str.isalpha()</td>
<td>False</td>
</tr>
<tr>
<td>识别字母和数字</td>
<td>input_str.isalnum()</td>
<td>True</td>
</tr>
<tr>
<td>识别空白字符</td>
<td>input_str.isspace()</td>
<td>False</td>
</tr>
<tr>
<td>input_str &#x3D; ‘hello’  识别小写字母</td>
<td>input_str.islower()</td>
<td>True</td>
</tr>
<tr>
<td>识别大写字母</td>
<td>input_str.isupper()</td>
<td>False</td>
</tr>
<tr>
<td>识别字符串是否以指定前缀开头</td>
<td>input_str.startswith(‘he’)</td>
<td>True</td>
</tr>
<tr>
<td>识别字符串是否以指定后缀结尾</td>
<td>input_str.endswith(‘lo’)</td>
<td>False</td>
</tr>
</tbody></table>
<h3 id="数字相关"><a href="#数字相关" class="headerlink" title="数字相关"></a>数字相关</h3><table>
<thead>
<tr>
<th>需求</th>
<th>输入</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>绝对值</td>
<td><strong>abs</strong>(-5)</td>
<td>5</td>
</tr>
<tr>
<td>商和余数</td>
<td><strong>divmod</strong>(13,2)</td>
<td>(6,1)</td>
</tr>
<tr>
<td>四舍六入五看齐,奇进偶不进</td>
<td><strong>round</strong>(3.50)</td>
<td>4</td>
</tr>
<tr>
<td>求 a 的 b 次幂（取余）</td>
<td><strong>pow</strong>(5,2) , <strong>pow</strong>(5,2,3)</td>
<td>(25, 1)</td>
</tr>
<tr>
<td>求和</td>
<td><strong>sum</strong>([1,2,3,4,5,6,7,8,9,10])</td>
<td>55</td>
</tr>
<tr>
<td>求最小值</td>
<td><strong>min</strong>(3,2,5,19,6,3)</td>
<td>2</td>
</tr>
<tr>
<td>求最大值</td>
<td><strong>max</strong>(3,5,12,8,5,11)</td>
<td>12</td>
</tr>
<tr>
<td>创建不可变的数字序列</td>
<td><strong>list</strong>(range(1, 10, 2)</td>
<td>[1, 3, 5, 7, 9]</td>
</tr>
<tr>
<td>十进制 → 二进制，八进制，十六进制</td>
<td><strong>bin</strong>(10), <strong>oct</strong>(10), <strong>hex</strong>(10)</td>
<td>0b1010, ‘0o12’, ‘0xa’</td>
</tr>
<tr>
<td>返回一个Unicode编码的整数对应的字符</td>
<td><strong>chr</strong>(65)</td>
<td>‘A’</td>
</tr>
<tr>
<td>创建一个复数</td>
<td><strong>complex</strong>(3,4)</td>
<td>(3+4j)</td>
</tr>
<tr>
<td>保留一位小数</td>
<td><strong>round</strong>(3.14159, 1)</td>
<td>3.1</td>
</tr>
</tbody></table>
<h3 id="列表相关"><a href="#列表相关" class="headerlink" title="列表相关"></a>列表相关</h3><table>
<thead>
<tr>
<th>需求</th>
<th>输入</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>i &#x3D; [1, 2, 3]  末尾增加元素</td>
<td>i.<strong>append</strong>(4)</td>
<td>[1, 2, 3, 4]</td>
</tr>
<tr>
<td>将另一个可迭代对象中的元素添加到列表末尾</td>
<td>i.<strong>extend</strong>([4, 5])</td>
<td>[1, 2, 3, 4, 5]</td>
</tr>
<tr>
<td>在指定位置插入一个元素</td>
<td>i.<strong>insert</strong>(1, ‘a’)</td>
<td>[1, ‘a’, 2, 3]</td>
</tr>
<tr>
<td>移除列表中第一个匹配的元素</td>
<td>i.<strong>remove</strong>(2)</td>
<td>[1, 3]</td>
</tr>
<tr>
<td>返回列表的浅拷贝，生成一个独立的副本</td>
<td>i.<strong>copy</strong>()</td>
<td>[1, 2, 3]</td>
</tr>
<tr>
<td>列表（集合，字典）清空</td>
<td>i.<strong>clear</strong>()</td>
<td>[]</td>
</tr>
<tr>
<td>统计元素出现的次数</td>
<td>i.<strong>count</strong>(1)</td>
<td>1</td>
</tr>
<tr>
<td>反向存放</td>
<td>i.<strong>reverse</strong>()</td>
<td>[3, 2, 1]</td>
</tr>
<tr>
<td>排序（反向）</td>
<td>i.<strong>sort</strong>(reverse&#x3D;False)</td>
<td>[3, 2, 1]</td>
</tr>
<tr>
<td>iterable&#x3D;[True, True, False] 可迭代对象中所有元素是否为真</td>
<td><strong>all</strong>(iterable)</td>
<td>False</td>
</tr>
<tr>
<td>iterable &#x3D; [False, False, True] 可迭代对象中有元素是否为真</td>
<td><strong>any</strong>(iterable)</td>
<td>True</td>
</tr>
<tr>
<td>iterable &#x3D; [1, 2, 3]</td>
<td><strong>sum</strong>(iterable)</td>
<td>6</td>
</tr>
<tr>
<td>numbers &#x3D; [1, 2, 3]，letters &#x3D; [‘a’, ‘b’, ‘c’] 打包</td>
<td><strong>zip</strong>(numbers, letters)</td>
<td>[(1, ‘a’), (2, ‘b’), (3, ‘c’)]</td>
</tr>
</tbody></table>
<h3 id="字典相关"><a href="#字典相关" class="headerlink" title="字典相关"></a>字典相关</h3><table>
<thead>
<tr>
<th>需求</th>
<th>输入</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>i &#x3D; {‘a’: 1, ‘b’: 2}  字典清空</td>
<td>i.<strong>clear</strong>()</td>
<td>{}</td>
</tr>
<tr>
<td>如果键存在于字典中，则返回该键的值，否则返回None或指定默认值</td>
<td>i.<strong>get</strong>(‘a’)；i.get(‘c’)</td>
<td>1；None</td>
</tr>
<tr>
<td>返回字典中的键值对列表,可以配合list使用，list(i.items())</td>
<td>list(i.<strong>items</strong>())</td>
<td>[(‘a’, 1), (‘b’, 2)]</td>
</tr>
<tr>
<td>获得键列表   list(i.keys())</td>
<td>list(i.<strong>keys</strong>())</td>
<td>[‘a’, ‘b’]</td>
</tr>
<tr>
<td>获得值列表   list(i.value())</td>
<td>list(i.<strong>value</strong>())</td>
<td>[1,2]</td>
</tr>
<tr>
<td>合并d1 &#x3D; {‘a’: 10, ‘b’: 20, ‘c’: 30} d2 &#x3D; {‘b’: 200, ‘d’: 400}</td>
<td>d1.<strong>update</strong>(d2)</td>
<td>{‘a’: 10, ‘b’: 200, ‘c’: 30, ‘d’: 400}</td>
</tr>
</tbody></table>
<h2 id="二、单行命令"><a href="#二、单行命令" class="headerlink" title="二、单行命令"></a>二、单行命令</h2><h3 id="生成等差数列"><a href="#生成等差数列" class="headerlink" title="生成等差数列"></a>生成等差数列</h3><p>生成一个从1到10的等差数列，公差为1。放入列表list1中。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">list1 = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="built_in">print</span>(list1)</span><br></pre></td></tr></table></figure>
<p>输出结果<code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code></p>
<h3 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h3><p>切片操作符[::-1]。从后向前取值，步长为-1，即实现字符串反转。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>输出结果<code>!dlroW ,olleH</code></p>
<h3 id="列表去重"><a href="#列表去重" class="headerlink" title="列表去重"></a>列表去重</h3><p>使用set()函数将列表转换为集合，自动去除重复元素，再将其转换回列表。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">list2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">unique_list = <span class="built_in">list</span>(<span class="built_in">set</span>(list2))</span><br><span class="line"><span class="built_in">print</span>(unique_list)</span><br></pre></td></tr></table></figure>
<p>输出结果<code>[1, 2, 3, 4, 5]</code></p>
<h3 id="简洁计算阶乘"><a href="#简洁计算阶乘" class="headerlink" title="简洁计算阶乘"></a>简洁计算阶乘</h3><p>当n等于0时，阶乘为1；否则，阶乘等于n乘以n-1的阶乘。此处递归未定义函数，实际应用中需确保递归深度可控。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">factorial = <span class="keyword">lambda</span> n:<span class="number">1</span> <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">else</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(factorial(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<p>输出结果<code>120</code></p>
<h3 id="统计字符串中单词出现次数"><a href="#统计字符串中单词出现次数" class="headerlink" title="统计字符串中单词出现次数"></a>统计字符串中单词出现次数</h3><p>str.count()方法用于统计字符串中指定子串（在此例中为’hello’）出现的次数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">text = <span class="string">&quot;hello world hello python&quot;</span></span><br><span class="line">word_count = text.count(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(word_count)</span><br></pre></td></tr></table></figure>
<p>输出结果<code>2</code></p>
<h3 id="生成斐波那契数列"><a href="#生成斐波那契数列" class="headerlink" title="生成斐波那契数列"></a>生成斐波那契数列</h3><p>使用列表推导式结合append()函数生成斐波那契数列。fibonacci初始为[0, 1]，接着逐次计算前两项之和，不断扩展列表。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">fibonacci = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">[fibonacci.append(fibonacci[i] + fibonacci[i+<span class="number">1</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span>(fibonacci)</span><br></pre></td></tr></table></figure>
<p>输出结果<code>[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]</code></p>
<h3 id="快速交换两个变量值"><a href="#快速交换两个变量值" class="headerlink" title="快速交换两个变量值"></a>快速交换两个变量值</h3><p>Python允许同时赋值多个变量</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a, b = <span class="number">10</span>, <span class="number">20</span></span><br><span class="line">a, b = b, a</span><br><span class="line"><span class="built_in">print</span>(a, b) </span><br></pre></td></tr></table></figure>
<p>输出结果<code>20 10</code></p>
<h3 id="求最大公约数（GCD）"><a href="#求最大公约数（GCD）" class="headerlink" title="求最大公约数（GCD）"></a>求最大公约数（GCD）</h3><p>Python内置math模块中的gcd()函数，直接计算两个数的最大公约数。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">gcd = math.gcd(<span class="number">48</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(gcd)</span><br></pre></td></tr></table></figure>
<p>输出结果<code>6</code></p>
<h3 id="列表元素排序并保持原索引"><a href="#列表元素排序并保持原索引" class="headerlink" title="列表元素排序并保持原索引"></a>列表元素排序并保持原索引</h3><p>使用sorted()函数对列表索引进行排序，key参数指定按照my_list对应位置的元素值进行排序。这样，原列表的元素顺序不变，但索引已按元素值排序。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">my_list = [ <span class="string">&#x27;elderberry&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;date&#x27;</span>,]</span><br><span class="line">sorted_list = <span class="built_in">sorted</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(my_list)), key=<span class="keyword">lambda</span> i: my_list[i])</span><br><span class="line"><span class="built_in">print</span>(sorted_list)</span><br></pre></td></tr></table></figure>
<p>输出结果<code>[1, 2, 3, 4, 0]</code></p>
<h3 id="使用列表推导式高效生成新列表"><a href="#使用列表推导式高效生成新列表" class="headerlink" title="使用列表推导式高效生成新列表"></a>使用列表推导式高效生成新列表</h3><p>列表推导式可以简洁地根据现有列表numbers生成一个新的列表squared</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squared = [num **<span class="number">2</span> <span class="keyword">for</span> num <span class="keyword">in</span> numbers]</span><br><span class="line"><span class="built_in">print</span>(squared)</span><br></pre></td></tr></table></figure>
<p>输出结果<code>[1, 4, 9, 16, 25]</code></p>
<h3 id="矩阵转置"><a href="#矩阵转置" class="headerlink" title="矩阵转置"></a>矩阵转置</h3><p>zip()函数将矩阵的行转为列，再使用map()和list()将结果转换为列表形式</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">matrix = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">transposed = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">list</span>, <span class="built_in">zip</span>(*matrix)))</span><br><span class="line"><span class="built_in">print</span>(transposed)</span><br></pre></td></tr></table></figure>
<p>输出结果<code>[[1, 3, 5], [2, 4, 6]]</code></p>
<h3 id="快速判断素数"><a href="#快速判断素数" class="headerlink" title="快速判断素数"></a>快速判断素数</h3><p>检查n是否能被2到其平方根之间的任何数整除。如果都不能整除，则返回True，表示n是素数。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">all</span>(n % i != <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(n**<span class="number">0.5</span>)+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(is_prime(<span class="number">17</span>)) </span><br></pre></td></tr></table></figure>
<p>输出结果<code>True</code></p>
<h3 id="itertools-快速组合"><a href="#itertools-快速组合" class="headerlink" title="itertools 快速组合"></a>itertools 快速组合</h3><p>使用itertools.product()函数生成多个列表的笛卡尔积，结果为一个包含所有组合的列表。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">cartesian_product = <span class="built_in">list</span>(itertools.product([<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&quot;C&quot;</span>], [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br><span class="line"><span class="built_in">print</span>(cartesian_product)</span><br></pre></td></tr></table></figure>
<p>输出结果<code>[(&#39;A&#39;, &#39;a&#39;, 1), (&#39;A&#39;, &#39;a&#39;, 2), (&#39;A&#39;, &#39;a&#39;, 3), (&#39;A&#39;, &#39;b&#39;, 1), (&#39;A&#39;, &#39;b&#39;, 2), (&#39;A&#39;, &#39;b&#39;, 3), (&#39;A&#39;, &#39;c&#39;, 1), (&#39;A&#39;, &#39;c&#39;, 2), (&#39;A&#39;, &#39;c&#39;, 3), (&#39;B&#39;, &#39;a&#39;, 1), (&#39;B&#39;, &#39;a&#39;, 2), (&#39;B&#39;, &#39;a&#39;, 3), (&#39;B&#39;, &#39;b&#39;, 1), (&#39;B&#39;, &#39;b&#39;, 2), (&#39;B&#39;, &#39;b&#39;, 3), (&#39;B&#39;, &#39;c&#39;, 1), (&#39;B&#39;, &#39;c&#39;, 2), (&#39;B&#39;, &#39;c&#39;, 3), (&#39;C&#39;, &#39;a&#39;, 1), (&#39;C&#39;, &#39;a&#39;, 2), (&#39;C&#39;, &#39;a&#39;, 3), (&#39;C&#39;, &#39;b&#39;, 1), (&#39;C&#39;, &#39;b&#39;, 2), (&#39;C&#39;, &#39;b&#39;, 3), (&#39;C&#39;, &#39;c&#39;, 1), (&#39;C&#39;, &#39;c&#39;, 2), (&#39;C&#39;, &#39;c&#39;, 3)]</code></p>
<h3 id="遍历列表并打印索引和对应的值"><a href="#遍历列表并打印索引和对应的值" class="headerlink" title="遍历列表并打印索引和对应的值"></a>遍历列表并打印索引和对应的值</h3><p>使用 enumerate() 函数遍历列表并打印索引和对应的值, 创建生成器对象</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">generator = ((i, j) <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]))</span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> generator:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(((i, j) <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]))))</span><br></pre></td></tr></table></figure>
<p>输出结果<code>(0, &#39;A&#39;) (1, &#39;B&#39;) (2, &#39;C&#39;)</code> or <code>[(0, &#39;A&#39;), (1, &#39;B&#39;), (2, &#39;C&#39;)]</code></p>
<h3 id="对列表中元素排序"><a href="#对列表中元素排序" class="headerlink" title="对列表中元素排序"></a>对列表中元素排序</h3><p>对可迭代对象做排序操作</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法一</span></span><br><span class="line">lst = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">9</span>,<span class="number">18</span>,<span class="number">5</span>]</span><br><span class="line">lst.sort()  </span><br><span class="line"><span class="built_in">print</span>(lst) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(lst))</span><br><span class="line"></span><br><span class="line"><span class="comment">#倒序</span></span><br><span class="line"><span class="built_in">sorted</span>(lst,reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果<code>[1, 5, 5, 6, 7, 9, 12, 13, 18]</code></p>
<h3 id="将对象中对应的元素打包成一个元组"><a href="#将对象中对应的元素打包成一个元组" class="headerlink" title="将对象中对应的元素打包成一个元组"></a>将对象中对应的元素打包成一个元组</h3><p>将可迭代的对象作为参数，将对象中对应的元素打包成一个元组，然后返回由这些元组组成的列表。如果各个迭代器的元素个数不一致，则返回的列表长度与最短的对象相同。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">lst1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>]</span><br><span class="line">lst2 = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>]</span><br><span class="line">lst3 = [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>, <span class="string">&#x27;six&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> el <span class="keyword">in</span> <span class="built_in">zip</span>(lst1, lst2, lst3):</span><br><span class="line">    <span class="built_in">print</span>(el)</span><br></pre></td></tr></table></figure>
<p>输出结果<code>(&#39;a&#39;, &#39;1&#39;, &#39;one&#39;) (&#39;b&#39;, &#39;2&#39;, &#39;two&#39;) (&#39;c&#39;, &#39;3&#39;, &#39;three&#39;) (&#39;d&#39;, &#39;4&#39;, &#39;four&#39;) (&#39;e&#39;, &#39;5&#39;, &#39;five&#39;) (&#39;f&#39;, &#39;6&#39;, &#39;six&#39;)</code></p>
<h3 id="python内置进制转换"><a href="#python内置进制转换" class="headerlink" title="python内置进制转换"></a>python内置进制转换</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">dec = <span class="built_in">input</span>(<span class="string">&#x27;10进制数为：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;转换为二进制为：&quot;</span>, <span class="built_in">bin</span>(dec))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;转换为八进制为：&quot;</span>, <span class="built_in">oct</span>(dec))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;转换为十六进制为：&quot;</span>, <span class="built_in">hex</span>(dec))</span><br><span class="line"> </span><br><span class="line">string1 = <span class="string">&#x27;101010&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;二进制字符串转换成十进制数为：&#x27;</span>，<span class="built_in">int</span>(string1,<span class="number">2</span>))</span><br><span class="line">string1 = <span class="string">&#x27;367&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;八进制字符串转换成十进制数为：&#x27;</span>，<span class="built_in">int</span>(string1,<span class="number">8</span>))</span><br><span class="line">string3 = <span class="string">&#x27;FFF&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;十六进制字符串转换成十进制数为：&#x27;</span>，<span class="built_in">int</span>(string1,<span class="number">16</span>))</span><br></pre></td></tr></table></figure>


<h3 id="求质数"><a href="#求质数" class="headerlink" title="求质数"></a>求质数</h3><p><a href="https://github.com/Ynjxsjmh/ArticlePickup/blob/master/%E6%B1%82%E8%B4%A8%E6%95%B0%E7%AE%97%E6%B3%95%E7%9A%84N%20%E7%A7%8D%E5%A2%83%E7%95%8C.md">求质数的几种境界</a></p>
<h3 id="求质因数"><a href="#求质因数" class="headerlink" title="求质因数"></a>求质因数</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">all</span>(n%i !=<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="built_in">int</span>(n**<span class="number">0.5</span>)+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_primes</span>(<span class="params">n</span>):</span><br><span class="line">    prime_list =[]</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> is_prime(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="built_in">int</span>(n**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> is_prime(j) <span class="keyword">and</span> n%j ==<span class="number">0</span>:</span><br><span class="line">                prime_list.append(j)</span><br><span class="line">                n = <span class="built_in">int</span>(n/j)</span><br><span class="line">    prime_list.append(n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prime_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">prime_list_out = get_primes(num)</span><br><span class="line">prime_list_out.sort()</span><br><span class="line">formatted_output = <span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, prime_list_out))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(formatted_output)</span><br></pre></td></tr></table></figure>


<h3 id="map-对可迭代对象中的每个元素应用一个函数"><a href="#map-对可迭代对象中的每个元素应用一个函数" class="headerlink" title="map 对可迭代对象中的每个元素应用一个函数"></a>map 对可迭代对象中的每个元素应用一个函数</h3><p>int,str等函数都可以作为 map 的函数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squared_numbers = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, numbers)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(squared_numbers))</span><br></pre></td></tr></table></figure>

<h3 id="filter-函数根据条件筛选"><a href="#filter-函数根据条件筛选" class="headerlink" title="filter 函数根据条件筛选"></a>filter 函数根据条件筛选</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">filtered_numbers = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, numbers)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(filtered_numbers))</span><br></pre></td></tr></table></figure>

<h3 id="打乱列表元素，得到全排列"><a href="#打乱列表元素，得到全排列" class="headerlink" title="打乱列表元素，得到全排列"></a>打乱列表元素，得到全排列</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_permutate</span>(<span class="params">lst</span>):</span><br><span class="line">    per = <span class="built_in">list</span>(itertools.permutations(lst))</span><br><span class="line">    <span class="keyword">return</span> per</span><br></pre></td></tr></table></figure>



<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ol>
<li><a href="https://mp.weixin.qq.com/s/1g92Sr3WtB67XEiFrCv8oQ">https://mp.weixin.qq.com/s/1g92Sr3WtB67XEiFrCv8oQ</a></li>
<li><a href="https://mp.weixin.qq.com/s/IOFMUH5rIfUF0GhNpsenlg">https://mp.weixin.qq.com/s/IOFMUH5rIfUF0GhNpsenlg</a></li>
<li><a href="https://mp.weixin.qq.com/s/OmTFXbwIOATSHIOJK1CVkQ">https://mp.weixin.qq.com/s/OmTFXbwIOATSHIOJK1CVkQ</a></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>OS Module of Python</title>
    <url>/2024/05/15/os-module-of-python/</url>
    <content><![CDATA[<p><strong><font size=6>Python os 模块</font></strong></p>
<h2 id="一、os模块"><a href="#一、os模块" class="headerlink" title="一、os模块"></a>一、os模块</h2><p>os 模块提供了非常丰富的方法用来处理文件和目录。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure>
<h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在操作系统命令行中运行一个shell命令</span></span><br><span class="line">os.system(command)</span><br></pre></td></tr></table></figure>
<h3 id="操作工作目录"><a href="#操作工作目录" class="headerlink" title="操作工作目录"></a>操作工作目录</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回当前工作目录的路径</span></span><br><span class="line">os.getcwd()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改变当前工作目录</span></span><br><span class="line">os.chdir(path)</span><br></pre></td></tr></table></figure>
<h3 id="得到环境变量"><a href="#得到环境变量" class="headerlink" title="得到环境变量"></a>得到环境变量</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">os.environ</span><br></pre></td></tr></table></figure>
<h3 id="列出子目录"><a href="#列出子目录" class="headerlink" title="列出子目录"></a>列出子目录</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回指定目录下的所有文件和子目录的名称列表</span></span><br><span class="line">os.listdir(path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成子目录列表</span></span><br><span class="line">sub_contents = [content.name <span class="keyword">for</span> content <span class="keyword">in</span> os.scandir(root_dir) <span class="keyword">if</span> content.is_dir()]</span><br><span class="line">sub_contents = [item <span class="keyword">for</span> item <span class="keyword">in</span> os.listdir(root_dir) <span class="keyword">if</span> os.path.isdir(os.path.join(root_dir, item))]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成子文件列表</span></span><br><span class="line">sub_files = [file.name <span class="keyword">for</span> file <span class="keyword">in</span> os.scandir(root_dir) <span class="keyword">if</span> file.is_file()]</span><br><span class="line">sub_files = [item <span class="keyword">for</span> item <span class="keyword">in</span> os.listdir(root_dir) <span class="keyword">if</span> os.path.isfile(os.path.join(root_dir, item))]</span><br></pre></td></tr></table></figure>
<h3 id="创建，删除，重命名目录"><a href="#创建，删除，重命名目录" class="headerlink" title="创建，删除，重命名目录"></a>创建，删除，重命名目录</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建单个目录（父目录必须存在）</span></span><br><span class="line">os.mkdir(path)</span><br><span class="line"><span class="comment"># 创建递归目录（允许创建父目录），路径，权限，目录存在不触发异常</span></span><br><span class="line">os.makedirs(path, mode=<span class="number">511</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个空目录</span></span><br><span class="line">os.rmdir(path)</span><br><span class="line"><span class="comment"># 递归删除一个或多个空目录</span></span><br><span class="line">os.removedirs(path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名文件或目录</span></span><br><span class="line">os.rename(old, new)</span><br><span class="line"><span class="comment"># 递归重命名文件或目录</span></span><br><span class="line">os.renames(old, new)</span><br></pre></td></tr></table></figure>


<h2 id="二、os-path模块"><a href="#二、os-path模块" class="headerlink" title="二、os.path模块"></a>二、os.path模块</h2><h3 id="检查路径，返回布尔值"><a href="#检查路径，返回布尔值" class="headerlink" title="检查路径，返回布尔值"></a>检查路径，返回布尔值</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查路径path是否存在</span></span><br><span class="line">os.path.exists(path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查路径path是否是一个文件</span></span><br><span class="line">os.path.isfile(path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查路径path是否是一个目录</span></span><br><span class="line">os.path.isdir(path)</span><br></pre></td></tr></table></figure>
<h3 id="拼接、分割路径"><a href="#拼接、分割路径" class="headerlink" title="拼接、分割路径"></a>拼接、分割路径</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将多个路径拼接成一个路径</span></span><br><span class="line">os.path.join(path1, path2, ...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将路径path分割为目录和文件名</span></span><br><span class="line">os.path.split(path)</span><br></pre></td></tr></table></figure>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回path的绝对路径</span></span><br><span class="line">os.path.abspath(path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回路径path的文件名部分</span></span><br><span class="line">os.path.basename(path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回路径path的目录部分</span></span><br><span class="line">os.path.dirname(path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回path的文件大小</span></span><br><span class="line">os.path.getsize(path)</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://www.runoob.com/python/os-file-methods.html">https://www.runoob.com/python/os-file-methods.html</a></li>
</ol>
<h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><ol>
<li>Pathlib: <a href="https://mp.weixin.qq.com/s/a19JmJOtSff2TqhTYaD8ig">https://mp.weixin.qq.com/s/a19JmJOtSff2TqhTYaD8ig</a></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>Quick Start of Gaussian</title>
    <url>/2024/05/14/quick-start-of-gaussian/</url>
    <content><![CDATA[<h1 id="Notes-of-gaussian"><a href="#Notes-of-gaussian" class="headerlink" title="Notes of gaussian"></a>Notes of gaussian</h1><p>本教程基于 HPC of zhenggroup 集群环境</p>
<p>参考资料 <a href="http://sobereva.com/list.html">http://sobereva.com/list.html</a></p>
<h2 id="零、理论基础"><a href="#零、理论基础" class="headerlink" title="零、理论基础"></a>零、理论基础</h2><h4 id="泛函-基组设置"><a href="#泛函-基组设置" class="headerlink" title="泛函&#x2F;基组设置"></a>泛函&#x2F;基组设置</h4><p><a href="http://sobereva.com/272">简谈量子化学计算中DFT泛函的选择</a><br><a href="http://sobereva.com/336">谈谈量子化学中基组的选择</a></p>
<h4 id="激发态"><a href="#激发态" class="headerlink" title="激发态"></a>激发态</h4><p><a href="http://sobereva.com/265">乱谈激发态的计算方法</a><br><a href="http://sobereva.com/314">Gaussian中用TDDFT计算激发态和吸收、荧光、磷光光谱的方法</a><br><a href="http://sobereva.com/230">电子激发任务中轨道跃迁贡献的计算</a></p>
<h2 id="一、输入文件"><a href="#一、输入文件" class="headerlink" title="一、输入文件"></a>一、输入文件</h2><h3 id="input-gjf"><a href="#input-gjf" class="headerlink" title="input.gjf"></a>input.gjf</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%mem=84GB</span><br><span class="line">%nprocshared=48</span><br><span class="line">%chk=COF-3-td.chk</span><br><span class="line">#p PBE1PBE scrf=(smd,solvent=water) def2TZVP em=GD3BJ TD(nstates=10) IOp(9/40=4)</span><br><span class="line"></span><br><span class="line">COF-3</span><br><span class="line"></span><br><span class="line">0 1</span><br><span class="line"> C                 33.03196170  -14.12931527    1.88576471</span><br><span class="line"> H                 31.92769914  -14.10953751    2.72772983</span><br><span class="line"> O                 30.78605907  -13.40639889    2.39344442</span><br><span class="line"> N                 30.71722291  -12.70823752    1.19042342</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="二、输出文件"><a href="#二、输出文件" class="headerlink" title="二、输出文件"></a>二、输出文件</h2><p>chk → fchk<br>&#x2F;public&#x2F;software&#x2F;g16&#x2F;formchk filename</p>
<h4 id="HOMO-LUMO-gap"><a href="#HOMO-LUMO-gap" class="headerlink" title="HOMO-LUMO gap"></a>HOMO-LUMO gap</h4><h5 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h5><p><a href="http://sobereva.com/543">正确地认识分子的能隙(gap)、HOMO和LUMO</a><br>(计算DFT, 虚拟态，轨道没有真实存在)<br>HOMO-LUMO gap &#x3D; E(LUMO) - E(HOMO) &gt; 0<br>(UV-Vis：波长最大的吸收峰位置; TDDFT，真实态，电子态真实存在)<br>Optical gap: 基态电子态通过吸收光子所能跃迁到的最低激发态对应的激发能，S0态极小点结构下S0到S1态的垂直跃迁对应的激发能。</p>
<ol>
<li>HOMO-LUMO gap越小，一般认为导电性越好。</li>
<li>HOMO-LUMO gap越小，通常极化率也越大</li>
</ol>
<h2 id="三、结果分析"><a href="#三、结果分析" class="headerlink" title="三、结果分析"></a>三、结果分析</h2><h4 id="Excitation、S-D、Visualization"><a href="#Excitation、S-D、Visualization" class="headerlink" title="Excitation、S&#x2F;D、Visualization"></a>Excitation、S&#x2F;D、Visualization</h4><h5 id="Excitation"><a href="#Excitation" class="headerlink" title="Excitation"></a>Excitation</h5><ol>
<li>Multiwfn</li>
<li>input.out (out文件路径)</li>
<li>18-Electron excitation analysis </li>
<li>15-Print major MO transitions in all excited states</li>
</ol>
<h5 id="S-D"><a href="#S-D" class="headerlink" title="S&#x2F;D"></a>S&#x2F;D</h5><ol>
<li>Multiwfn</li>
<li>COF-3-td.fchk (fchk文件路径)</li>
<li>18-Electron excitation analysis </li>
<li>1-Analyze and visualize hole&amp;electron distribution, transition density, and transition electric&#x2F;magnetic dipole moment density</li>
<li>input.out (out文件路径)</li>
<li>S0→S？ </li>
<li>1-Visualize and analyze hole, electron, transition density and so on</li>
<li>2-Medium quality grid, covering whole system, about 512000 points in total<br>Sm index&#x2F;D index</li>
<li><strong>3-Show isosurface of hole and electron distribution simultaneously</strong></li>
<li><strong>7-Show isosurface of charge density difference</strong></li>
</ol>
<h5 id="Visualization"><a href="#Visualization" class="headerlink" title="Visualization"></a>Visualization</h5><p><a href="https://www.bilibili.com/video/BV1B94y1J7gR/?spm_id_from=333.788&vd_source=dbd7edddb514b6a82b44048682e9c391">https://www.bilibili.com/video/BV1B94y1J7gR/?spm_id_from=333.788&amp;vd_source=dbd7edddb514b6a82b44048682e9c391</a><br>cube 文件生成 + VMD可视化</p>
<h2 id="文献引用"><a href="#文献引用" class="headerlink" title="文献引用"></a>文献引用</h2><p>[1] def2-TZVP基组 <a href="https://doi.org/10.1063/1.467146">https://doi.org/10.1063/1.467146</a><br>[2] Multiwfn <a href="https://doi.org/10.1002/jcc.22885">https://doi.org/10.1002/jcc.22885</a><br>[3] 溶剂模型 <a href="https://doi.org/10.1063/1.3359469">https://doi.org/10.1063/1.3359469</a><br>[4] xtb <a href="https://doi.org/10.1021/acs.jctc.8b01176">https://doi.org/10.1021/acs.jctc.8b01176</a><br>[5] D3BJ <a href="https://doi.org/10.1002/jcc.21759">https://doi.org/10.1002/jcc.21759</a></p>
]]></content>
      <categories>
        <category>DFT</category>
      </categories>
      <tags>
        <tag>gaussian</tag>
      </tags>
  </entry>
  <entry>
    <title>Quick Start of CP2K</title>
    <url>/2024/06/07/quick-start-of-cp2k/</url>
    <content><![CDATA[<p><strong><font size=6>Quick Start of CP2K</font></strong></p>
<p>本教程基于 HPC of zhenggroup 集群环境</p>
<h1 id="一、CP2K介绍"><a href="#一、CP2K介绍" class="headerlink" title="一、CP2K介绍"></a>一、CP2K介绍</h1><h2 id="关于CP2K"><a href="#关于CP2K" class="headerlink" title="关于CP2K"></a>关于CP2K</h2><ol>
<li>CP2K是一种量子化学和固态物理第一性原理计算软件包，可以执行固态，液态，分子，和生物系统的计算模拟。</li>
<li>CP2K是开源免费程序，使用混合高斯和平面波基组GPW和GAPW的DFT方法比平面波基组计算更<strong>快</strong>。</li>
<li>CP2K用到好多非常新和前沿的算法<br><strong>OT(Orbital Transformation)，</strong><br>ASPC(Always stable predictor corrector)，<br>ADMM(Auxiliary Density Matrix Methods)，<br>PIMD(pathintegral Molecular Dynamics)，<br>adaptive buffered QM&#x2F;MM</li>
<li>相关文章 <a href="https://www.cp2k.org/science">https://www.cp2k.org/science</a></li>
<li>催化：ACS Catal. 2019, 9 (9), 7876-7887</li>
</ol>
<h2 id="CP2K的应用和局限"><a href="#CP2K的应用和局限" class="headerlink" title="CP2K的应用和局限"></a>CP2K的应用和局限</h2><p><strong>应用:</strong> DFT,AIMD,(QM&#x2F;MM),NEB,MD    <a href="https://www.cp2k.org/features">https://www.cp2k.org/features</a><br><strong>局限:</strong> 1. 对导体计算较慢，OT算法算有带隙的材料可以很快收敛。导体一般用较慢的对角化方法。<br>         2. 磁性体系提前指定自旋多重度。<br>         3. 高斯基组带来的基组重叠误差（Basis Set Superposition Error, BSSE），不适合计算结合能。VASP使用平面波基组不存在此问题。<br>         4. 能量计算使用VASP更准确</p>
<h1 id="二、CP2K使用"><a href="#二、CP2K使用" class="headerlink" title="二、CP2K使用"></a>二、CP2K使用</h1><h2 id="输入文件-环境准备"><a href="#输入文件-环境准备" class="headerlink" title="输入文件+环境准备"></a>输入文件+环境准备</h2><p><code>*.inp</code>,<code>(coord.inc/xyz)</code>,<code>CP2K.pbs</code></p>
<p>在提交脚本<code>cp2k.pbs</code>内添加以下内容</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /public/software/gcc-9.3.0/gcc-9.3.0_env.sh</span><br><span class="line"><span class="built_in">source</span> /public/software/intel2020u2//intel2020u2_env.sh</span><br><span class="line"><span class="built_in">export</span> OMP_NUM_THREADS=1</span><br><span class="line">mpirun  -n 48 /public/software/cp2k-8.1/exe/local/cp2k.popt  -i cp2k.inp &gt; cp2k.out</span><br></pre></td></tr></table></figure>
<h2 id="cp2k-inp-常用参数说明"><a href="#cp2k-inp-常用参数说明" class="headerlink" title="cp2k.inp 常用参数说明"></a><code>cp2k.inp</code> 常用参数说明</h2><p>CP2K手册<a href="https://manual.cp2k.org/trunk/index.html">https://manual.cp2k.org/trunk/index.html</a><br>关键词以section和subsection的形式套娃，每一个section都是以【&amp;section_name】开头的，以【&amp;END section_name 】结尾的。(顺序随意，嵌套不能乱)每一行只写一个关键词，关键词后面写参数，大小写和空格不敏感。</p>
<h3 id="通用参数GLOBAL"><a href="#通用参数GLOBAL" class="headerlink" title="通用参数GLOBAL"></a>通用参数<code>GLOBAL</code></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&amp;GLOBAL</span><br><span class="line">  PROJECT cp2k                              <span class="comment"># 任务名称</span></span><br><span class="line">  RUN_TYPE GEO_OPT                          <span class="comment"># 计算类型 ENERGY,ENERGY_FORCE,GEO_OPT,CELL_OPT,VIBRATIONAL_ANALYSIS,BAND,MD,PINT</span></span><br><span class="line">  PRINT_LEVEL LOW                           <span class="comment"># 输出等级</span></span><br><span class="line">&amp;END GLOBAL</span><br></pre></td></tr></table></figure>
<h3 id="体系的力和能量FORCE-EVAL"><a href="#体系的力和能量FORCE-EVAL" class="headerlink" title="体系的力和能量FORCE_EVAL"></a>体系的力和能量<code>FORCE_EVAL</code></h3><ol>
<li><strong><code>SUBSYS</code>(subsystem): coordinates, topology, molecules and cell</strong><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&amp;FORCE_EVAL</span><br><span class="line">  METHOD Quickstep                          <span class="comment"># 使用DFT的GPW方法进行计算原子受力</span></span><br><span class="line">  &amp;SUBSYS</span><br><span class="line"><span class="comment"># --------------- Structure --------------- #</span></span><br><span class="line">    &amp;TOPOLOGY</span><br><span class="line">      &amp;CENTER_COORDINATES                   <span class="comment"># 结构放在盒子中间</span></span><br><span class="line">      &amp;END CENTER_COORDINATES</span><br><span class="line">      COORD_FILE_FORMAT xyz</span><br><span class="line">      COORD_FILE_NAME  ./coord.xyz</span><br><span class="line">    &amp;END TOPOLOGY</span><br><span class="line"><span class="comment"># ------------ Lattice vectors ------------ #</span></span><br><span class="line">    &amp;CELL                                   <span class="comment"># 也可输入 `ABC 10 11 13` 代表正交晶系，单位埃</span></span><br><span class="line">      A    8.42    0.00    0.00</span><br><span class="line">      B    4.21    7.29    0.00</span><br><span class="line">      C    0.00    0.00   19.32</span><br><span class="line">      PERIODIC XYZ                          <span class="comment"># NONE,X,XY,XYZ,XZ,Y,YZ,Z  XYZ代表三个方向周期性计算</span></span><br><span class="line">    &amp;END CELL</span><br><span class="line"><span class="comment"># ------------ Basis, Potential ----------- #</span></span><br><span class="line">    &amp;KIND Au                                <span class="comment"># 元素种类</span></span><br><span class="line">      ELEMENT Au                            </span><br><span class="line">      BASIS_SET DZVP-MOLOPT-SR-GTH-q11      <span class="comment"># 基组设置(对应文件里存在的条目)</span></span><br><span class="line">      POTENTIAL GTH-PBE                     <span class="comment"># 赝势设置</span></span><br><span class="line">    &amp;END KIND</span><br><span class="line"><span class="comment"># ----------------------------------------- #</span></span><br><span class="line">  &amp;END SUBSYS</span><br><span class="line">  ...</span><br><span class="line">&amp;END FORCE_EVAL</span><br></pre></td></tr></table></figure>
其他输入原子坐标方式<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Method 1：inc --------------------------- #</span></span><br><span class="line">&amp;COORD  </span><br><span class="line">    @INCLUDE <span class="string">&#x27;coord.inc&#x27;</span>  <span class="comment">#xyz文件去掉前两行</span></span><br><span class="line">&amp;END COORD</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2：Cartesian coordinates --------- #</span></span><br><span class="line">&amp;COORD </span><br><span class="line">C          -3.36178719   11.43419295    1.72360000</span><br><span class="line">H           3.11299203   11.00326708    1.72360000</span><br><span class="line">...</span><br><span class="line">&amp;END COORD </span><br></pre></td></tr></table></figure></li>
<li><strong>DFT: Parameter needed by LCAO DFT programs <strong>(Quickstep)</strong> 关于自洽循环(电子步)的计算参数</strong><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&amp;FORCE_EVAL</span><br><span class="line">  &amp;DFT</span><br><span class="line">    BASIS_SET_FILE_NAME  BASIS_MOLOPT       <span class="comment"># 基组文件路径</span></span><br><span class="line">    POTENTIAL_FILE_NAME  POTENTIAL          <span class="comment"># 赝势文件路径</span></span><br><span class="line"><span class="comment"># --------------- Quickstep --------------- #</span></span><br><span class="line">    &amp;QS                                     <span class="comment"># </span></span><br><span class="line">      EPS_DEFAULT 1.0E-12                   <span class="comment"># 高精度计算时，EPS_DEFAULT 1.0E-14</span></span><br><span class="line">    &amp;END QS                                 </span><br><span class="line"><span class="comment"># ----------------- Grid ------------------ #</span></span><br><span class="line">    &amp;MGRID                                  <span class="comment"># </span></span><br><span class="line">      NGRIDS 4                              <span class="comment"># 多重网格叠加做FFT, 值越大，算得越快，越不精确</span></span><br><span class="line">      CUTOFF 500                            <span class="comment"># 整体网格精度的最高值 https://manual.cp2k.org/trunk/methods/dft/cutoff.html，尽量&gt;800</span></span><br><span class="line">      REL_CUTOFF 50                         <span class="comment"># 控制有多少网格点落到最精细的级别</span></span><br><span class="line">    &amp;END MGRID </span><br><span class="line"><span class="comment"># ----------------- SCF ------------------- #</span></span><br><span class="line">    &amp;SCF                                    </span><br><span class="line">      SCF_GUESS ATOMIC                      <span class="comment"># 初猜/可以改成RESTART</span></span><br><span class="line">      EPS_SCF 1.0E-6                        <span class="comment"># 能量收敛精度</span></span><br><span class="line">      MAX_SCF 100                           <span class="comment"># SCF循环圈数</span></span><br><span class="line">      <span class="comment"># ------ OT, DIAGONALIZATION -------- #</span></span><br><span class="line">      &amp;OT T                                 <span class="comment"># 使用OT(Orbital Transformation)优化波函数</span></span><br><span class="line">      MINIMIZER CG                          <span class="comment"># 共轭梯度法(最可靠)(CG)/迭代子空间直接反演法(速度快)(DIIS)/布罗伊登法(BROYDEN)  </span></span><br><span class="line">      LINESEARCH 3PNT                       <span class="comment"># 搜索算法</span></span><br><span class="line">      PRECONDITIONER FULL_SINGLE_INVERSE    <span class="comment"># 适用于大型系统；难收敛改Full All</span></span><br><span class="line">      &amp;END OT </span><br><span class="line">      <span class="comment"># &amp;DIAGONALIZATION ON                 # 对角化方法，不如OT快</span></span><br><span class="line">      <span class="comment">#   ALGORITHM STANDARD </span></span><br><span class="line">      <span class="comment"># &amp;END DIAGONALIZATION </span></span><br><span class="line">      <span class="comment"># ----------------------------------- #</span></span><br><span class="line">    &amp;END SCF                                </span><br><span class="line"><span class="comment"># --- eXchange and Correlation potential -- #</span></span><br><span class="line">    &amp;XC                                     <span class="comment"># 交换-关联密度泛函，要与基组和赝势的选择一致。</span></span><br><span class="line">      &amp;XC_FUNCTIONAL PBE </span><br><span class="line">      &amp;END XC_FUNCTIONAL </span><br><span class="line">    &amp;END XC</span><br><span class="line"><span class="comment"># ----------------- Print ----------------- #</span></span><br><span class="line">    &amp;PRINT                                  <span class="comment"># 输出参数 https://manual.cp2k.org/trunk/CP2K_INPUT/FORCE_EVAL/DFT/PRINT.html </span></span><br><span class="line">      &amp;FORCES ON                            <span class="comment"># 输出力</span></span><br><span class="line">      &amp;END FORCES</span><br><span class="line">    &amp;END PRINT</span><br><span class="line"><span class="comment"># ----------------------------------------- #</span></span><br><span class="line">  &amp;END DFT</span><br><span class="line">  ...</span><br><span class="line">&amp;END FORCE_EVAL</span><br></pre></td></tr></table></figure></li>
<li><strong>其他常用<code>&amp;DFT</code>参数</strong></li>
</ol>
<table>
<thead>
<tr>
<th align="center">&amp;DFT 参数</th>
<th align="center">设置</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BASIS_SET_FILE_NAME</td>
<td align="center">BASIS_MOLOPT, BASIS_MOLOPT_UCL</td>
<td align="center">基组文件，前面可加路径${DATAPATH} 需要@SET DATAPATH ….</td>
</tr>
<tr>
<td align="center">POTENTIAL_FILE_NAME</td>
<td align="center">GTH_POTENTIALS</td>
<td align="center">赝势文件</td>
</tr>
<tr>
<td align="center">UKS</td>
<td align="center">T</td>
<td align="center">开壳层</td>
</tr>
<tr>
<td align="center">ROK</td>
<td align="center">T</td>
<td align="center">限制性开壳层</td>
</tr>
<tr>
<td align="center">MULTIPLICITY</td>
<td align="center">整数</td>
<td align="center">闭壳层1，开壳层双重态2，三重态3</td>
</tr>
<tr>
<td align="center">WFN_RESTART_FILE_NAME</td>
<td align="center">.&#x2F;RESTART.wfn（波函数路径）</td>
<td align="center">需要同时开启<code>&amp;DFT/&amp;SCF</code>中的<code>SCF_GUESS RESTART</code></td>
</tr>
<tr>
<td align="center">PLUS_U_METHOD</td>
<td align="center">见手册</td>
<td align="center">DFT+U （U值在 &amp;KIND 里控制）</td>
</tr>
<tr>
<td align="center">SURFACE_DIPOLE_CORRECTION</td>
<td align="center">T</td>
<td align="center">表面，偶极校正 &lt;&#x3D;&gt; IDIPOL &#x3D; T</td>
</tr>
<tr>
<td align="center">SURF_DIP_DIR</td>
<td align="center">Z</td>
<td align="center">Z方向 &lt;&#x3D;&gt; IDIPOL &#x3D; 3</td>
</tr>
</tbody></table>
<ol start="4">
<li><p><strong>OT和Diagonalization比较</strong><br>OT：速度快，没有高斯展宽，对于金属系统收敛性差，不支持DFT+U，以及KPOINTS<br>Dia：计算量大，要设置高斯展宽，支持DFT+U和KPOINTS</p>
</li>
<li><p><strong>PIRNT</strong><br><code>&amp;FORCE_EVAL/</code> 中添加<code>&amp;PRINT/&amp;FORCES ON/&amp;END FORCES</code>，输出力。<br><code>&amp;FORCE_EVAL/&amp;DFT/&amp;SCF</code> 中添加<code>&amp;PRINT/&amp;RESTART FILENAME =RESTART.wfn/&amp;END RESTART</code>，输出波函数。</p>
</li>
<li><p><strong>基组</strong><br>计算精度，SZV &lt; DZVP &lt; TZVP &lt; TZV2P &lt; TZV2PX<br><strong>VP(Valence Polarized同时添加极化函数)</strong><br>VASP平面波基组(PW)，不同的体系设定相同的平面波截断能（ENCUT），那么用到的基组都是一样的。<br>高斯基组计算AB体系和A体系使用的基组不一样，AB中B的部分基组也贡献于描述A原子。(基组重叠误差，基组越大，误差越小，SR相比与普通的基组，速度略有提升，BSSE误差增大)<br>AB体系算出来的能量被低估。(<strong>计算吸附能、结合能等都会偏负</strong>，E(AB) – E(A) – E(B))</p>
</li>
<li><p><strong>对角化K点设置</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&amp;FORCE_EVAL</span><br><span class="line">  &amp;DFT</span><br><span class="line"><span class="comment"># ----------------KPOINTS------------------ #</span></span><br><span class="line">    &amp;KPOINTS</span><br><span class="line">      SCHEME MONKHORST-PACK 3 3 3           </span><br><span class="line">      SYMMETRY T                            <span class="comment"># 识别晶胞对称性</span></span><br><span class="line">      VERBOSE T                             <span class="comment"># 输出</span></span><br><span class="line">      FULL_GRID T</span><br><span class="line">    &amp;END KPOINTS</span><br><span class="line"><span class="comment"># ----------------------------------------- #</span></span><br><span class="line">  &amp;END DFT</span><br><span class="line">&amp;END FORCE_EVAL</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="原子运动参数MOTION"><a href="#原子运动参数MOTION" class="headerlink" title="原子运动参数MOTION"></a>原子运动参数<code>MOTION</code></h3><h4 id="结构和晶胞优化"><a href="#结构和晶胞优化" class="headerlink" title="结构和晶胞优化"></a>结构和晶胞优化</h4><ol>
<li><p><strong>几何结构优化：<code>GEO_OPT</code></strong><br><a href="https://manual.cp2k.org/trunk/methods/optimization/geometry.html">cp2k manual - geometry optimization</a><br><a href="https://manual.cp2k.org/trunk/methods/optimization/geometry.html#">ex:H2O</a><br><code>&amp;GLOBAL</code>中<code>RUN_TYPE</code>设置<code>GEO_OPT</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&amp;MOTION</span><br><span class="line"><span class="comment"># ------------ Geometry Optimizer --------- #</span></span><br><span class="line">  &amp;GEO_OPT</span><br><span class="line">    MAX_ITER 400</span><br><span class="line">    OPTIMIZER BFGS                          <span class="comment"># LBFGS大体系，BFGS针中小体系，CG更为Robust</span></span><br><span class="line">    MAX_FORCE 6.0E-4</span><br><span class="line">  &amp;END GEO_OPT</span><br><span class="line"><span class="comment"># ----------------------------------------- #</span></span><br><span class="line">&amp;END MOTION</span><br></pre></td></tr></table></figure>
<p>输出文件：(以H2O为例) <code>H2O.out</code>, <code>H2O-pos-1.xyz</code>, <code>H2O-1.restart</code>, <code>H2O-1.restart.bak-1,2,3</code><br><code>H2O-1.restart.bak-*</code>代表计算结束前<code>*</code>次迭代结果，<code>..bak-1</code>和<code>H2O-1.restart</code>相同<br>终止后续算：使用<code>H2O-1.restart</code>作为input文件重新提交任务</p>
</li>
<li><p><strong>晶胞优化：<code>CELL_OPT</code></strong><br><a href="https://manual.cp2k.org/trunk/CP2K_INPUT/MOTION/CELL_OPT.html#cell-opt">cp2k manual - cell optimization</a><br><code>&amp;GLOBAL</code>中<code>RUN_TYPE</code>设置<code>CELL_OPT</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&amp;MOTION</span><br><span class="line"><span class="comment"># -------------- Cell Optimizer ----------- #</span></span><br><span class="line">  &amp;CELL_OPT</span><br><span class="line">    MAX_ITER 400</span><br><span class="line">    OPTIMIZER CG                            <span class="comment"># LBFGS大体系，BFGS针中小体系，CG更为Robust</span></span><br><span class="line">    KEEP_ANGLES                             <span class="comment"># 固定角度</span></span><br><span class="line">    KEEP_SYMMETRY T                         <span class="comment"># 固定对称性   </span></span><br><span class="line">    <span class="comment"># CONSTRAINT Z                          # 固定Z方向</span></span><br><span class="line">    TYPE DIRECT_CELL_OPT                    <span class="comment"># 同时优化晶胞和里面的位置(默认)</span></span><br><span class="line">    MAX_FORCE 6.0E-4</span><br><span class="line">  &amp;END GEO_OPT</span><br><span class="line"><span class="comment"># ----------------------------------------- #</span></span><br><span class="line">&amp;END MOTION</span><br></pre></td></tr></table></figure></li>
<li><p><strong>坐标固定：<code>CONSTRAINT</code></strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&amp;MOTION</span><br><span class="line"><span class="comment"># ------------- Constraints --------------- #</span></span><br><span class="line">  &amp;CONSTRAINT</span><br><span class="line">    <span class="comment"># ---------- Fixed atoms -------------- #</span></span><br><span class="line">    &amp;FIXED_ATOMS</span><br><span class="line">      COMPONENTS_TO_FIX XYZ                 <span class="comment"># 限制固定的方向，也可以设置X,XY等  </span></span><br><span class="line">      LIST 1..54</span><br><span class="line">      LIST 289..324</span><br><span class="line">    &amp;END FIXED_ATOMS</span><br><span class="line">  &amp;END CONSTRAINT</span><br><span class="line"><span class="comment"># ----------------------------------------- #  </span></span><br><span class="line">&amp;MOTION</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="频率计算"><a href="#频率计算" class="headerlink" title="频率计算"></a>频率计算</h4><ol>
<li><strong><code>&amp;GLOBAL</code>中<code>RUN_TYPE</code>设置<code>VIBRATIONAL_ANALYSIS</code>，输出信息精度调高</strong></li>
<li><strong>SCF优化精度不变，同时添加<code>&amp;VIBRATIONAL_ANALYSIS</code></strong><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&amp;VIBRATIONAL_ANALYSIS</span><br><span class="line">  NPROC_REP 48                              <span class="comment"># 总核数=节点数*核数</span></span><br><span class="line">  DX 0.01                                   <span class="comment"># 步长</span></span><br><span class="line">  FULLY_PERIODIC F                          <span class="comment"># 是否周期性</span></span><br><span class="line"><span class="comment"># ----------------- Print ----------------- #</span></span><br><span class="line">  &amp;PRINT</span><br><span class="line">    &amp;MOLDEN_VIB                             <span class="comment"># 生成振动模式的 MOLDEN 文件</span></span><br><span class="line">    &amp;END</span><br><span class="line">    &amp;CARTESIAN_EIGS                         <span class="comment"># 输出输出频率计算中笛卡尔坐标系下的本征值和本征向量</span></span><br><span class="line">    &amp;END</span><br><span class="line">    &amp;PROGRAM_RUN_INFO                       <span class="comment"># 记录程序运行的详细信息</span></span><br><span class="line">      &amp;EACH</span><br><span class="line">        REPLICA_EVAL 1</span><br><span class="line">      &amp;END</span><br><span class="line">    &amp;END</span><br><span class="line">  &amp;END PRINT</span><br><span class="line"><span class="comment"># ----------------------------------------- #</span></span><br><span class="line">&amp;END VIBRATIONAL_ANALYSIS</span><br></pre></td></tr></table></figure></li>
<li><strong>自由能计算</strong><br><a href="http://sobereva.com/552">http://sobereva.com/552</a><br> 使用卢天的<code>~/software/Shermo_2.6/Shermo</code>计算<code>ZPE</code>，需要引用<br><code>10.1016/j.comptc.2021.113249</code></li>
</ol>
<h4 id="过渡态计算"><a href="#过渡态计算" class="headerlink" title="过渡态计算"></a>过渡态计算</h4><p><a href="http://sobereva.com/44">http://sobereva.com/44</a></p>
<ol>
<li><strong>DIMER</strong><br>在势能放置两个相邻的点 Dimer 来寻找 TS，通过不断重复旋转移动dimer，直到找到能量最高点。</li>
<li><strong>CINEB</strong><br>在 IS 到 FS 之间插入一系列结构，共插入P-1个，反应为0，产物为P。优化不是对每个点孤立地优化，优化过程所有点一起运动。插点结构受到<br>1.来自势能面的力（保留平行分量）；2.chain方向上的弹簧力（保留垂直分量）</li>
</ol>
<p><strong>CP2K-CINEB过程</strong><br><strong><code>&amp;GLOBAL</code>中<code>RUN_TYPE</code>设置<code>BAND</code></strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&amp;MOTION</span><br><span class="line"><span class="comment"># ----------------- Band ------------------ #</span></span><br><span class="line">  &amp;BAND</span><br><span class="line">  NPROC_REP 28</span><br><span class="line">  BAND_TYPE CI-NEB</span><br><span class="line">  ALIGN_FRAMES F</span><br><span class="line">  ROTATE_FRAMES F</span><br><span class="line">  NUMBER_OF_REPLICA 6</span><br><span class="line">  K_SPRING 0.08</span><br><span class="line">    <span class="comment"># ---------- Convergence -------------- #</span></span><br><span class="line">    &amp;CONVERGENCE_CONTROL</span><br><span class="line">      MAX_DR 0.01</span><br><span class="line">      MAX_FORCE 0.001</span><br><span class="line">      RMS_DR 0.02</span><br><span class="line">      RMS_FORCE 0.001</span><br><span class="line">    &amp;END</span><br><span class="line">    &amp;CI_NEB</span><br><span class="line">      NSTEPS_IT 5</span><br><span class="line">    &amp;END</span><br><span class="line">    &amp;OPTIMIZE_BAND</span><br><span class="line">      OPT_TYPE DIIS</span><br><span class="line">      OPTIMIZE_END_POINTS F</span><br><span class="line">    &amp;END</span><br><span class="line">    &amp;REPLICA</span><br><span class="line">      COORD_FILE_NAME ./1.xyz</span><br><span class="line">    &amp;END</span><br><span class="line">    &amp;REPLICA</span><br><span class="line">      COORD_FILE_NAME ./2.xyz</span><br><span class="line">    &amp;END</span><br><span class="line">    &amp;REPLICA</span><br><span class="line">      COORD_FILE_NAME ./3.xyz</span><br><span class="line">    &amp;END</span><br><span class="line">    &amp;REPLICA</span><br><span class="line">      COORD_FILE_NAME ./4.xyz</span><br><span class="line">    &amp;END</span><br><span class="line">    &amp;REPLICA</span><br><span class="line">      COORD_FILE_NAME ./5.xyz</span><br><span class="line">    &amp;END</span><br><span class="line">    &amp;PROGRAM_RUN_INFO</span><br><span class="line">    &amp;END</span><br><span class="line">    &amp;CONVERGENCE_INFO</span><br><span class="line">    &amp;END</span><br><span class="line">  &amp;END BAND</span><br><span class="line"><span class="comment"># ----------------------------------------- #</span></span><br><span class="line">&amp;END MOTION</span><br></pre></td></tr></table></figure>

<p><strong>CP2K-DIMER过程</strong><br><a href="http://bbs.keinsci.com/thread-23516-1-1.html">http://bbs.keinsci.com/thread-23516-1-1.html</a></p>
<ol>
<li>初猜选取dimer结构，得到coord.inc文件</li>
<li>设置优化方向 <code>sed -i &#39;1,2d&#39; coord.inc</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">METHOD DIMER</span><br><span class="line">&amp;DIMER</span><br><span class="line">  DR 0.01</span><br><span class="line">  ANGLE_TOLERANCE [deg] 4.0</span><br><span class="line">  INTERPOLATE_GRADIENT</span><br><span class="line">  &amp;DIMER_VECTOR</span><br><span class="line">     @INCLUDE &#x27;DIMER_VECTOR&#x27;</span><br><span class="line">  &amp;END DIMER_VECTOR</span><br><span class="line">  &amp;ROT_OPT</span><br><span class="line">    OPTIMIZER CG</span><br><span class="line">    MAX_ITER 10</span><br><span class="line"></span><br><span class="line">    MAX_DR 3.0E-3</span><br><span class="line">    MAX_FORCE 6.0E-4</span><br><span class="line">    &amp;CG</span><br><span class="line">      # MAX_STEEP_STEPS 15</span><br><span class="line">      &amp;LINE_SEARCH</span><br><span class="line">        TYPE 2PNT</span><br><span class="line">      &amp;END LINE_SEARCH</span><br><span class="line">    &amp;END CG</span><br><span class="line">  &amp;END ROT_OPT</span><br><span class="line">&amp;END DIMER</span><br></pre></td></tr></table></figure>
<h4 id="杂化泛函（待更新）"><a href="#杂化泛函（待更新）" class="headerlink" title="杂化泛函（待更新）"></a>杂化泛函（待更新）</h4><h4 id="单点计算（待更新）"><a href="#单点计算（待更新）" class="headerlink" title="单点计算（待更新）"></a>单点计算（待更新）</h4><h4 id="AIMD"><a href="#AIMD" class="headerlink" title="AIMD"></a>AIMD</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&amp;QS</span><br><span class="line">  EPS_DEFAULT 1.0E-14</span><br><span class="line">  EXTRAPOLATION ASPC</span><br><span class="line">  EXTRAPOLATION_ORDER 3</span><br><span class="line">&amp;END QS</span><br></pre></td></tr></table></figure>
<ol>
<li>EXTRAPOLATION 控制波函数外推，在做结构优化&#x2F;MD的时候，下一离子步的波函数用前几个离子步的波函数组合可以得到非常快的SCF收敛。建议用ASPC(Always stable predictor corrector)，注：不能和K点设置同时使用。</li>
<li>EXTRAPOLATION_ORDER是ASPC extrapolation order。一般用默认值3。</li>
</ol>
<p>这两个参数可以促进AIMD的时候的每一离子步的SCF收敛，默认打开。这也是cp2k算AIMD比较快的一个原因。</p>
<h2 id="输出文件"><a href="#输出文件" class="headerlink" title="输出文件"></a>输出文件</h2><p>(mermaid 模块还在测试)</p>
<pre class="mermaid">graph TD
A[cp2k输入文件]-->B[GLOBAL]
A-->C[FORCE_EVAL]
A-->D[MOTION]
    C-->E[SUBSYS]
    C-->H[PRINT]
    C-->F[DFT]
        E-->G[CELL]
        E-->I[COORD]
        E-->J[TOPOLOGY]
        E-->K[KIND]
        F-->O[QS]
        F-->L[SCF]
        F-->N[MGRID]
        F-->P[XC]
        F-->T[PRINT]
            L-->M[OT]
            L-->Q[DIAGONALIZATION]</pre>


<h1 id="三、数据处理"><a href="#三、数据处理" class="headerlink" title="三、数据处理"></a>三、数据处理</h1><h3 id="脚本使用"><a href="#脚本使用" class="headerlink" title="脚本使用"></a>脚本使用</h3><p><code>*.out</code>,<code>(*.wfn.bak-*)</code>wfn会不断覆盖，记录最后三步的波函数</p>
<h1 id="四、学习资料"><a href="#四、学习资料" class="headerlink" title="四、学习资料"></a>四、学习资料</h1><ol>
<li>CP2K的tutorials：<br><a href="https://www.cp2k.org/exercises">https://www.cp2k.org/exercises</a><br><a href="https://www.cp2k.org/howto">https://www.cp2k.org/howto</a></li>
<li>CP2K手册：<a href="http://manual.cp2k.org/trunk/">http://manual.cp2k.org/trunk/</a></li>
<li>CP2K的google group：<a href="https://groups.google.com/group/cp2k">https://groups.google.com/group/cp2k</a></li>
<li>Zevan的博客：<a href="http://kenshin325.lofter.com/tag/cp2k">http://kenshin325.lofter.com/tag/cp2k</a></li>
<li>兰一的知乎专栏：<a href="https://zhuanlan.zhihu.com/cp2k-tutorial">https://zhuanlan.zhihu.com/cp2k-tutorial</a></li>
<li>CP2K有用的工具： <a href="https://www.cp2k.org/tools">https://www.cp2k.org/tools</a></li>
<li>python编写的cp2k输入文件生成器(最高支持5.1)：<br><a href="https://github.com/avishart/CP2K_Editor">https://github.com/avishart/CP2K_Editor</a></li>
<li>难收敛<a href="http://sobereva.com/665">http://sobereva.com/665</a></li>
<li><a href="http://wiki.cheng-group.net/wiki/software_usage/cp2k/cp2k/">http://wiki.cheng-group.net/wiki/software_usage/cp2k/cp2k/</a></li>
</ol>
]]></content>
      <categories>
        <category>DFT</category>
      </categories>
      <tags>
        <tag>cp2k</tag>
      </tags>
  </entry>
  <entry>
    <title>Quick Start of VASP</title>
    <url>/2024/05/14/quick-start-of-vasp/</url>
    <content><![CDATA[<p><strong><font size=6>Quick Start of VASP</font></strong></p>
<p>本教程基于 HPC of zhenggroup 集群环境</p>
<h2 id="一、VASP简介"><a href="#一、VASP简介" class="headerlink" title="一、VASP简介"></a>一、VASP简介</h2><h3 id="关于-VASP"><a href="#关于-VASP" class="headerlink" title="关于 VASP"></a>关于 VASP</h3><p><a href="https://www.vasp.at/info/about/">https://www.vasp.at/info/about/</a><br>The Vienna Ab initio Simulation Package (VASP) is a computer program for atomic scale materials modelling, e.g. electronic structure calculations and quantum-mechanical molecular dynamics, from first principles.</p>
<p>VASP是用于原子尺度材料模拟的计算程序，基于第一性原理</p>
<ol>
<li>计算电子结构性质</li>
<li>计算量子力学分子动力学</li>
</ol>
<p>VASP <strong>computes an approximate solution</strong> to <strong>the many-body Schrödinger equation</strong>, either within density functional theory (DFT), solving the Kohn-Sham equations, or within the Hartree-Fock (HF) approximation, solving the Roothaan equations. Hybrid functionals that mix the Hartree-Fock approach with density functional theory are implemented as well.Furthermore, Green’s functions methods (GW quasiparticles, and ACFDT-RPA) and many-body perturbation theory (2nd-order Møller-Plesset) are available in VASP.</p>
<p>VASP计算多体薛定谔方程近似解。</p>
<ol>
<li>DFT求解Kohn-Sham方程</li>
<li>HF求解Roothaan方程</li>
<li>杂化泛函</li>
<li>格林函数方法(GW准粒子和ACFDT-RPA)和多体微扰理论(二阶Møller-Plesset)</li>
</ol>
<p>In VASP, central quantities, like the one-electron orbitals, the electronic charge density, and the local potential are expressed in <strong>plane wave basis sets</strong>. The interactions between the electrons and ions are described using norm-conserving or ultrasoft pseudopotentials, or the projector-augmented-wave method.</p>
<ol>
<li>中心量，如单电子轨道、电子电荷密度和局域势都以平面波基组表示。</li>
<li>电子和离子之间的相互作用以模守恒赝势、超软赝势或缀加投影缀加波(PAW)方法来描述。</li>
</ol>
<p>To determine the electronic groundstate, VASP makes use of <strong>efficient iterative matrix diagonalisation techniques</strong>, like the residual minimisation method with direct inversion of the iterative subspace (RMM-DIIS) or blocked Davidson algorithms. These are coupled to highly efficient Broyden and Pulay density mixing schemes to speed up the self-consistency cycle.</p>
<p>为确定电子基态，VASP使用高效迭代的矩阵对角化技术，如带有迭代子空间直接反演的残差极小化方法(RMM-DIIS)或阻塞Davidson算法。这些算法与高效Broyden和Pulay密度混合方案相耦合，用以加快自洽循环。</p>
<p>VASP 算法<br>结构优化算法：conjugate gradient, Quasi-Newton or damped molecular dynamics<br>过渡态搜索：Nudged elastic band methods</p>
<h3 id="VASP-应用和局限"><a href="#VASP-应用和局限" class="headerlink" title="VASP 应用和局限"></a>VASP 应用和局限</h3><p>VASP 侧重表面、体相材料计算<br><strong>PBE泛函 + PAW赝势 + PW基组</strong><br><code>Perdew-Burke- Ernzerhof</code>+<code>projector-augmented-wave</code>+<code>plane wave</code><br>PBE泛函：Phys. Rev. Lett. 78, 1396 (1997)<br>关于PAW算法的介绍：<a href="https://zhuanlan.zhihu.com/p/575479762">https://zhuanlan.zhihu.com/p/575479762</a><br>PW基组</p>
<ol>
<li>计算周期性的体系</li>
<li>体系不能过大，200原子以内</li>
</ol>
<h2 id="二、VASP使用"><a href="#二、VASP使用" class="headerlink" title="二、VASP使用"></a>二、VASP使用</h2><h3 id="输入文件"><a href="#输入文件" class="headerlink" title="输入文件"></a>输入文件</h3><p><code>INCAR</code>,<code>POSCAR</code>,<code>POTCAR</code>,<code>KPINTS</code>,<code>(OPTCELL)</code>,<code>vasp.pbs</code></p>
<h4 id="表面建模"><a href="#表面建模" class="headerlink" title="表面建模"></a>表面建模</h4><ol>
<li>真空层<br>R. Hoffmann, Angew. Chem. Int. Ed., 2013, 52, 93-103<br>MS建模：<a href="https://www.bilibili.com/video/BV1b54y1672a/?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1b54y1672a/?spm_id_from=333.999.0.0</a><br>Modules-Amorphous Cell模块添加溶剂化层*</li>
<li>Wood表面标记<br>fcc(100)-c(2×2)  &lt;&#x3D;&gt;   fcc(100)-($\sqrt{2}$ × $\sqrt{2}$)R45°</li>
<li>结构，VASP仅识别文件名为<code>POSCAR</code>的结构，其他结构可以转换成<code>*.vasp</code>文件后重命名为<code>POSCAR</code><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> O  H                                                                   <span class="comment"># system</span></span><br><span class="line">   1.00000000000000                                                     <span class="comment"># 比例系数，压力</span></span><br><span class="line">    11.0000000000000000    0.0000000000000000    0.0000000000000000     <span class="comment"># 晶胞基矢a</span></span><br><span class="line">     0.0000000000000000   12.0000000000000000    0.0000000000000000     <span class="comment"># 晶胞基矢b</span></span><br><span class="line">     0.0000000000000000    0.0000000000000000   13.0000000000000000     <span class="comment"># 晶胞基矢c</span></span><br><span class="line">   O    H                                                               <span class="comment"># 元素识别</span></span><br><span class="line">     1     2                                                            <span class="comment"># 元素数量识别</span></span><br><span class="line">Selective                                                               <span class="comment"># 原子固定</span></span><br><span class="line">Cartesian                                                               <span class="comment"># 笛卡尔坐标、分数坐标</span></span><br><span class="line">        +10.7708483093   +11.6761039758   +0.0000000000  T T T          <span class="comment"># 原子1坐标         </span></span><br><span class="line">        +0.7421507349   +11.7181789381   +0.0000000000  T T T           <span class="comment"># 原子2坐标</span></span><br><span class="line">        +10.4870009558   +0.6057170861   +0.0000000000  T T T           <span class="comment"># 原子3坐标</span></span><br></pre></td></tr></table></figure></li>
<li>画图：MS，vesta，VMD，origin，illustrator</li>
</ol>
<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>在提交脚本<code>vasp.pbs</code>内添加以下内容</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法一：镜像</span></span><br><span class="line">module load singularity/3.8.7   <span class="comment"># 加载容器</span></span><br><span class="line">singularity run  /public/software/images/ase.sif  mpirun -np 48  vasp_std  1&gt;<span class="built_in">log</span> 2&gt;err   执行计算</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二：本地软件</span></span><br><span class="line">module load hdf5    <span class="comment"># 存储数据/并行I/O</span></span><br><span class="line">module load gcc/9.3.0   <span class="comment"># GNU 编译器套件</span></span><br><span class="line"><span class="built_in">source</span> /public/software/intel2020u2/intel2020u2_env.sh  <span class="comment"># intel 环境</span></span><br><span class="line">mpirun -np 48 /public/software/vasp.6.3.2/bin/vasp_std 1&gt;<span class="built_in">log</span> 2&gt;err   <span class="comment"># 执行计算</span></span><br></pre></td></tr></table></figure>

<h4 id="INCAR-常用参数说明"><a href="#INCAR-常用参数说明" class="headerlink" title="INCAR 常用参数说明"></a>INCAR 常用参数说明</h4><ol>
<li><p>输入输出</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SYSTEM = string          <span class="comment"># 注释行</span></span><br><span class="line"></span><br><span class="line">ISTART = 0|1             <span class="comment"># 存在WAVECAR，1; 否则，0初猜</span></span><br><span class="line">ICHAGE = 1|2             <span class="comment"># ISTART为0，取2用原子电荷密度组装|1：从CHGCAR文件读入</span></span><br><span class="line"></span><br><span class="line">NWRITE = 2               <span class="comment"># 控制输出信息的详细程度</span></span><br><span class="line">LCHARG = .T.             <span class="comment"># 输出电荷密度CHG/CHGCAR </span></span><br><span class="line">LWAVE = .T.              <span class="comment"># 输出波函数文件WAVECAR</span></span><br><span class="line">LVTOT = .T.              <span class="comment"># 输出总局域势LOCPOT</span></span><br><span class="line">LELF = .T.               <span class="comment"># 输出电子局域密度函数ELFCAR文件</span></span><br></pre></td></tr></table></figure></li>
<li><p>结构优化</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 泛函选择</span></span><br><span class="line">GGA = PE                 <span class="comment"># PBE泛函</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 电子步</span></span><br><span class="line">ALGO = N                 <span class="comment"># 电子优化算法;IALGO                 </span></span><br><span class="line">NELM = 200               <span class="comment"># 最大电子步数</span></span><br><span class="line">ISMEAR = 0|-5            <span class="comment"># 决定如何确定电子部分占据数，0,高斯展开|-5,布洛赫校正四面体方法，DOS|金属建议用正整数</span></span><br><span class="line">SIGMA = 0.05             <span class="comment"># 展宽越小，计算越精确，一般设置0.05 ~ 0.1</span></span><br><span class="line">ENCUT = 400              <span class="comment"># 平面波基的截断能</span></span><br><span class="line">PREC = N|A               <span class="comment"># 网格精度，建议一般优化取N|单点和频率取A </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 离子步</span></span><br><span class="line">IBRION = -1|0|1|2|3      <span class="comment"># 离子优化算法;-1离子不运动|0分子动力学模拟|1准牛顿法离子弛豫|2共轭梯度CG算法的离子弛豫</span></span><br><span class="line">POTIM = 0.1              <span class="comment"># 作用在力上的比例系数</span></span><br><span class="line">NSW = 500                <span class="comment"># 离子步长</span></span><br><span class="line">ISIF = 2|3               <span class="comment"># 控制离子运动，2晶胞不优化|3优化</span></span><br><span class="line">ISYM = 0|1               <span class="comment"># 对称性是否开启，算吸附态时建议为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 电子自旋、磁矩</span></span><br><span class="line">ISPIN = 1|2              <span class="comment"># 电子总自旋。1无自旋|2有自旋</span></span><br><span class="line">MAGMOM = N*M ...         <span class="comment"># 指定特定原子的磁矩</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 表面计算</span></span><br><span class="line">LDIPOL = .T.             <span class="comment"># 偶极矩校正开</span></span><br><span class="line">IDIPOL = 3               <span class="comment"># 偶极矩校正精度</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>频率计算</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">IBRION = 5               <span class="comment"># 频率计算</span></span><br><span class="line">NFREE = 2                <span class="comment"># 自由度</span></span><br><span class="line">POTIM = 0.015            <span class="comment"># 频率计算模式</span></span><br><span class="line">EDIFF = 1E-6             <span class="comment"># 防止虚频</span></span><br></pre></td></tr></table></figure></li>
<li><p>单点计算&#x2F;bader&#x2F;pdos</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">NSW = 1</span><br><span class="line"><span class="comment"># Bader</span></span><br><span class="line">LAECHG = .T.</span><br><span class="line">LCHARG = .T.</span><br><span class="line"><span class="comment"># Pdos 需要提高K点网格，有真空层的情况下扩大XY方向的K点</span></span><br><span class="line">ISMEAR = -5</span><br><span class="line">LORBIT = 11</span><br></pre></td></tr></table></figure>
<p>POTCAR</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /public/scripts/Pseudopotentials-VASP/potpaw_PBE/Cu/POTCAR  &gt;&gt; POTCAR</span><br></pre></td></tr></table></figure>
<p>KPOINTS<br><a href="https://www.bigbrosci.com/2017/12/10/ex18/">https://www.bigbrosci.com/2017/12/10/ex18/</a><br><a href="https://www.vasp.at/wiki/index.php/KPOINTS">https://www.vasp.at/wiki/index.php/KPOINTS</a></p>
</li>
</ol>
<h2 id="三、数据处理"><a href="#三、数据处理" class="headerlink" title="三、数据处理"></a>三、数据处理</h2><ol>
<li>检查输入文件<code>/public/scripts/checkinput.sh</code></li>
<li>查看优化结果<code>/public/scripts/ta.sh</code> </li>
<li>快速固定坐标<code>/public/scripts/dtoc.py</code></li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://www.vasp.org/howto">VASP 官网</a></li>
<li><a href="https://www.bigbrosci.com/">Learn VASP The Hard Way</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/571694885">https://zhuanlan.zhihu.com/p/571694885</a></li>
<li><a href="https://nwchemgit.github.io/pw-lecture.pdf">平面波基组和赝势理论</a></li>
<li><a href="https://www.tcm.phy.cam.ac.uk/castep/documentation/WebHelp/content/modules/castep/thcastepplanebasis.htm">https://www.tcm.phy.cam.ac.uk/castep/documentation/WebHelp/content/modules/castep/thcastepplanebasis.htm</a></li>
<li><a href="http://staff.ustc.edu.cn/~zyli/teaching.html">http://staff.ustc.edu.cn/~zyli/teaching.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/575479762">https://zhuanlan.zhihu.com/p/575479762</a></li>
</ol>
]]></content>
      <categories>
        <category>DFT</category>
      </categories>
      <tags>
        <tag>vasp</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/01/19/hello-world/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">
  <script id="hbeData" type="hbeData" data-hmacdigest="aaf5458c08c4d6cb540b35b558e9ca7a69a292b02aa58b4229b6dc9ca87732e6">9c6161198b65c0c7ed655745c399b5b33f07946e5b3e9f998cf3622b788ca0bc00bebd08285bf987e5fef81ea893268645ebe075c064b3e96eb0e912662766d8de53f8c03b89a084ec9357bc85b34118bc65557732901e429a42536299b9f5f70b89c55a71bda23bfb017c01c5d1d89df8aba3f294f7497b3ed3dbe98b5fab8095c865cc96bc6fdd61b9ae4b925ace5012b6278760c5088b6a17d81ae97571655375c9d5daf7b18a303b4fc1eaf685894979f69e9a1b02e8abe89e503b2ea766b66caae59e107ff9663a109ddfb9b7b1f6ad7834e8a2518a86e5d0812970fcee76fef9df81b402a455f5e14ee2496b19d3cab99ee4e8aa46ccd25865e8c10aed472d7a7312198480e94ec0ce718448d1c140d144949f676658bfeb2c39168c2a0200a73dfe1b9f146ff533c50fa58f797406a714f8b1e0d7e251ec678d8990eecca5c4a4e71767e2533985ed7c409d0150db6352e9cc36148afc8375ddd8a153e9f619f478c2e368f6767812ff520d170e3b2d68ca0adc4612b38e6a2d98a1dfc299d42b04a609fa5abe392137526a2a28aa88080014d9dfbae324e3afd21fcf6d5bb0fd9354be2e98d10792280f0a59494c8871fb25e5e531c55b8840c6db62fa30897bed9ba7fe75c5908a9d040adfbdab89f68e3d156bd9977ee3f1e3dd326533f2b8d14a33bfd023d6f35e96ecf2e294deb0df128e65155006ec252e07238e78cbac7c091d4cc84f4468bfd97c8193eee4e901cbd5c4adc3a0ad4f7dbdda6a29a1e9cc39e7a15a713e36eb4b126d7f16b9bbc428d10766ea060eb52f96d1a54a267908975f46492ad1305e2950c04c381fdd038c37d46aa174b897ac697a273e9b786518b86bf111f0f614ba71a28f6ef96d7f0a760844b036d2745c571e3450377f9f8e3b2a70d2525e4aacd8cc955a41100c72686bb5685fa9325e3edbe5e198d91d59112110687b35b8196a549ecb279efe7eb256583caf090194c8dba904032c846d3fb60a8b60b4f733fef80c1a5f00792d29db3627217609dab0714f66f72c349020779aaacc251e1c9f92adf897f3be0293d57f901e51cd0a6da5bf9b4c46b59d66924a15d1f55d471711f0df61141c6b3289fdd7e9dc6ca2a602c67108a702f15d3de44f1b7c24218a9cdd5881b0ce72d7c2fbf3bd4c5e5f7e51e8660ca2196a282176efe327c4a2d10dc8ebb0e5c7a78ada3ce6eb8393149d10e2d73a04cb9d736ff7ae43c42a98b5ff2744e6eccb75109caafd0c46628f3cd8eab852a3f6776bd9a09b3b2dac29e81eaa50da8eb3e5eda226736b1220f5a7f6f146799863ac8cab4048f1087e735b2aeb22718f423db90fda2bb6587139fe3707b23c76e9dccf454ecb63bdca085ba8fcc7ebdda429c1e9a193f993e11c84fbe529268022590288b18c2948891a0c4cd937f675abe708ff4adabacadfba09921949ebbfd90867700c38cf15236a0903edd9930f82a62d7273d7c2782defea3dd73f378f90e422ab35c6e18e4cee6543c1af74b500cd21ca7e00f2de844de997ebac362ff8c353c7643e7cea0c29eeff519420546da7c89b5c2df3490d90ed58c571ceec4dc3246b6ac104ed536eb40d61e194e472344dc1563e889985b569749ac933219120b10586da2cb15258c0a56b7f3138833cc46eb98f48d0d6914a16516a70700ab16d0a1d74d4f5de0c62c58df0b0d299461dfbeef76b87ccebfdad2b70dc540399cd0d7d1aa58759a5e2e6ca451a0691148da5bf07eb37e5a8897d0a7564c9b7dd6133fbc235dfc35bf82f5ccdbf8b60ce5c44ba4a063822c8999a5af78a4ea66e8d9925686ab3596c0e0cd5362fac4999e12fd30e7db61e6472d3eefd68c84ff41c6d527b027843148e476271e6562da7158082246b0e09bb84df2c01cd8f0ad02225bc761bc67b75982188476e78262b72af2dede4c52526b1f32986368842ae79b918a7e83970753861e467b40eda6760e4a973c96033df3e151ee83a1d8fec4f12bab834108d72f7a406c207d84bdea1a2456ec6b910f5bb32dec8ef87f64c485501495ed3486cf33733671438fb14b6f4cf16fe7dc19925cc54707134720c52811bde6d680ed12a72b0728667bffe5b20581199ed62cd2c223e056db3b384fa205aa688af54b3efcb96ff49fc928e990d1bac9baefcc46ecbf52da79d5c7f52283cfdca530225210e73e44e99e07b925b706413c5b96bc951f1faefe0f19430e69d1e4906a478f9c7f81d3805620679af1fb8eec92d53541c01e392bc54edef5bf410c12ba80500bfece3f7e45fa7f1cd23784b7dcaed28a3bced22d8f8afe166f4697ab4981dbe61fe742e82417ca185a2a97887f6979e10d3cc5a7613c1993afd7a0b37bc13e98eb08b10287f488023538e77cac690d29ae6d3044981c8ce4a18c9e966862cb6ee1978227ae5577440ffd5cb9570d647240bc455278bc904294ad76073aaed2d15400852367c3c82429fbd9dbaff8961da706aa1475d940f32aac12f414c997288edf92d879d5a532baff897e459eced83d5ed64b0ff37806daac889caae0c1750dc90d6c45d79c4eabab5bfa485018793a330418fe383c4e7460e5db6437cad025c921f98e6ce38282c33976c1429d441323047ea7ce8593047a71220c510593614f0c3147a7c4969ceed51cd068443c73d91c648ddf5b6ebf7ac6d6e8123d0c063d5e74a5e1542a07bc5ac7a53df6eb45d6fed93d9d3bbe2f71eec64656f0255a552ad8459f01ab17fdb3b86e88c592a9f51418edab9c18b5c6d7e46dabc35df5e0442530c7dc711cd35677beb383fc6703d9e0057ac1dd1c5115ccc1368d594b7d441228056a308a6c71d6dde1080cae07d1836a43ac3d8120f6904eb5cdd6e55aca3f0ace3888d52d492df9aa268e9eb33344f04a4f68a76c3fdabbc54540064e6f4bf2ec232bdc052bbc9fe7d3780c9580928e90a94b8fb4890f2c8632d5cda7ac9e5d0d80a8e5f4579fcd95af378e07b963089d146271742d9e145006e050919bd24f05f0f10e22e88907c61de6f5df3e0b3d9e72cb4743f67eff7f2548ff3b3c9c0c1d9a9a0e8674c435210cbe2c77417977ebdf94bbda64ab255a3b787d15480e8413b5f8fbe1432310e18befcd834203772b6f3accd7c5874a43c9ec8</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>private</tag>
      </tags>
  </entry>
  <entry>
    <title>Pearl</title>
    <url>/2024/07/29/pearl/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，您输入的密码错误，请检查后重新输入。" data-whm="抱歉, 当前文章不能被校验, 不过您还是可以看看解密后的内容。">
  <script id="hbeData" type="hbeData" data-hmacdigest="18a2410ef5eb081da8b31e4eaaf67860d5f9360ca6d68e6c2b3fa95296b4095c">9c6161198b65c0c7ed655745c399b5b3c22b49d63312cddb0a2937408d4045fef9e62b4649d6ecf6e9f8073af0e2a97754690bb8adb982f94baeb965b7d732a251cdca5db18dfaeab133b6958a2cd1448143e2f52451725bbc885ea0c90fc3065bdcb22152b47075ef109827b6bac52d7fa64ae61c7957ab85897fc304f8853bc934dea7b7f2c3c8c31a17d3cfdcaa0e1e8bb1071a3925b9d2d0040b32ee60707ebc985cef23122fc53574dd3e37a5255be3fdcec3676cffa2d9af7a8fe932a1292956dc7f14fdc2e078ee0463ed3c199932caf3d1c298e345968ca75ae6f5da76e0b4e120d0e45c38aaf2c039a985fa18de32ef7c2295b293eaba264f12750c698acd62d97448f760ec63ae633e75e9782494d7f7896046f3ddc831f879721d250e7f3c329753f96fb2939e1373696302ffde1fced64f46fc47711004b70657cfd5726b6e2ca7b1005afafeb0a86fd98e9c9d372a3049c4eb6b0c461bbeccf9731383d6c26dc42eb0b644b247df816346c846ead1c2c83d485e9a3a0e80c1518bf8bd48d0e8dc3cd0e9af340933e727590b38274250183c671d5a58e8fc97ae201e4d10d12df34d0fe4861467f4a9e17c2ebdebb84eb97e4d3633405ce415aa1168668479c399a152250fefc379789de58b6314a7b7c4f3070b65c7e3d9835f165edf095c1eac444e2aa5009c5dedecbf98d22659f2c1b9d28ad0773f45ad50a0cc0baad5b01a0f617d5688544131716446c1bcc4bb14ddf3d40f847b84479ddb5c3ecb9b29863a4eedca2e0a99962e2837992b65d81ec1d19bb3bc5333cbc5b15b4dc7121715b5fe276dd2206f6054</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">当前文章暂不对外可见，请输入密码后查看！</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>private</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes of Bash</title>
    <url>/2024/07/05/notes-of-bash/</url>
    <content><![CDATA[<p><strong><font size=6>Shell 笔记</font></strong></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Bash</tag>
      </tags>
  </entry>
  <entry>
    <title>Numpy Module of Python</title>
    <url>/2024/07/07/numpy-module-of-python/</url>
    <content><![CDATA[<h1 id="一、Numpy-Jupyter"><a href="#一、Numpy-Jupyter" class="headerlink" title="一、Numpy-Jupyter"></a>一、Numpy-Jupyter</h1><p><a href="/jupyter/numpy"><strong><font size=4>Numpy-Basis-Operations in Jupyter Notebook</font></strong></a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas Module of Python</title>
    <url>/2024/07/07/pandas-module-of-python/</url>
    <content><![CDATA[<h1 id="一、Pandas简介"><a href="#一、Pandas简介" class="headerlink" title="一、Pandas简介"></a>一、Pandas简介</h1><p><a href="https://inter.joyfulpandas.datawhale.club/Content/ch2.html#">https://inter.joyfulpandas.datawhale.club/Content/ch2.html#</a></p>
<h1 id="二、Pandas基本操作-Jupyter"><a href="#二、Pandas基本操作-Jupyter" class="headerlink" title="二、Pandas基本操作-Jupyter"></a>二、Pandas基本操作-Jupyter</h1><p><a href="/jupyter/pandas"><strong><font size=4>Pandas-Basis-Operations in Jupyter Notebook</font></strong></a><br>ipynb转化为md</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装 nbconvert</span><br><span class="line">pip install nbconvert</span><br><span class="line"></span><br><span class="line"># 转换 .ipynb 文件为 .md 文件</span><br><span class="line">jupyter nbconvert --to markdown notebook.ipynb</span><br></pre></td></tr></table></figure>
<h2 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">&#x27;./dataset/output.csv&#x27;</span>)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>

<h2 id="数据查看"><a href="#数据查看" class="headerlink" title="数据查看"></a>数据查看</h2><h4 id="1-查看数据前五行-后五行"><a href="#1-查看数据前五行-后五行" class="headerlink" title="1. 查看数据前五行, 后五行"></a>1. 查看数据前五行, 后五行</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.head())</span><br><span class="line"><span class="built_in">print</span>(df.tail())</span><br></pre></td></tr></table></figure>

<h4 id="2-查看数据信息（如数据类型、非空值数量等）："><a href="#2-查看数据信息（如数据类型、非空值数量等）：" class="headerlink" title="2. 查看数据信息（如数据类型、非空值数量等）："></a>2. 查看数据信息（如数据类型、非空值数量等）：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.info())</span><br></pre></td></tr></table></figure>

<h4 id="3-查看数据描述性统计信息（如均值、标准差等）："><a href="#3-查看数据描述性统计信息（如均值、标准差等）：" class="headerlink" title="3. 查看数据描述性统计信息（如均值、标准差等）："></a>3. 查看数据描述性统计信息（如均值、标准差等）：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.describe())</span><br></pre></td></tr></table></figure>

<h4 id="4-查看数据列名"><a href="#4-查看数据列名" class="headerlink" title="4. 查看数据列名"></a>4. 查看数据列名</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.columns)</span><br></pre></td></tr></table></figure>

<h4 id="5-查看数据索引"><a href="#5-查看数据索引" class="headerlink" title="5. 查看数据索引"></a>5. 查看数据索引</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.index)</span><br></pre></td></tr></table></figure>

<h4 id="6-按列名选择数据"><a href="#6-按列名选择数据" class="headerlink" title="6. 按列名选择数据"></a>6. 按列名选择数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(df[<span class="string">&#x27;ef100&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h2 id="数据修改"><a href="#数据修改" class="headerlink" title="数据修改"></a>数据修改</h2><h3 id="列操作"><a href="#列操作" class="headerlink" title="列操作"></a>列操作</h3><h4 id="7-按列名修改数据："><a href="#7-按列名修改数据：" class="headerlink" title="7. 按列名修改数据："></a>7. 按列名修改数据：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;index&#x27;</span>] = [<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(df))]</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h4 id="8-按列条件筛选数据行"><a href="#8-按列条件筛选数据行" class="headerlink" title="8. 按列条件筛选数据行"></a>8. 按列条件筛选数据行</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">filtered_df = df[df[<span class="string">&#x27;ef100&#x27;</span>] &gt; <span class="number">0</span>]</span><br><span class="line">filtered_df</span><br><span class="line"><span class="comment"># print(filtered_df)</span></span><br></pre></td></tr></table></figure>

<h4 id="9-按列条件修改数据"><a href="#9-按列条件修改数据" class="headerlink" title="9. 按列条件修改数据"></a>9. 按列条件修改数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.loc[df[<span class="string">&#x27;ef100&#x27;</span>] &gt; <span class="number">0</span>, <span class="string">&#x27;ef100&#x27;</span>] = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h4 id="10-按条件删除数据"><a href="#10-按条件删除数据" class="headerlink" title="10. 按条件删除数据"></a>10. 按条件删除数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = df[df[<span class="string">&#x27;ef100&#x27;</span>] != <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h4 id="11-添加新列"><a href="#11-添加新列" class="headerlink" title="11. 添加新列"></a>11. 添加新列</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;index^2&#x27;</span>] = [x*x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(df))]</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h4 id="12-删除列"><a href="#12-删除列" class="headerlink" title="12. 删除列"></a>12. 删除列</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = df.drop([<span class="string">&#x27;index^2&#x27;</span>, <span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;ef111&#x27;</span>], axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h4 id="13-重命名列"><a href="#13-重命名列" class="headerlink" title="13. 重命名列"></a>13. 重命名列</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = df.rename(columns=&#123;<span class="string">&#x27;mass&#x27;</span>: <span class="string">&#x27;atomic mass&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="14-设置索引"><a href="#14-设置索引" class="headerlink" title="14. 设置索引"></a>14. 设置索引</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = df.set_index(<span class="string">&#x27;Key&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h4 id="15-重置索引"><a href="#15-重置索引" class="headerlink" title="15. 重置索引"></a>15. 重置索引</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = df.reset_index()</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h3 id="行操作"><a href="#行操作" class="headerlink" title="行操作"></a>行操作</h3><h4 id="16-数据行排序"><a href="#16-数据行排序" class="headerlink" title="16. 数据行排序"></a>16. 数据行排序</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sorted_df = df.sort_values(by=<span class="string">&#x27;radius&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(sorted_df)</span><br></pre></td></tr></table></figure>

<h4 id="17-数据行分组"><a href="#17-数据行分组" class="headerlink" title="17. 数据行分组"></a>17. 数据行分组</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.loc[[<span class="string">&#x27;A&#x27;</span> <span class="keyword">in</span> strkey <span class="keyword">for</span> strkey <span class="keyword">in</span> df[<span class="string">&#x27;Key&#x27;</span>]], <span class="string">&#x27;Key&#x27;</span>] = <span class="string">&#x27;A+&#x27;</span></span><br><span class="line">grouped_df = df.groupby(<span class="string">&#x27;Key&#x27;</span>)</span><br><span class="line"><span class="comment"># print(grouped_df.mean())                # 计算分组后的平均值</span></span><br><span class="line"><span class="built_in">print</span>(grouped_df.get_group(<span class="string">&#x27;A+&#x27;</span>))</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name, group <span class="keyword">in</span> grouped_df:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Group: <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(group)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="18-合并数据行"><a href="#18-合并数据行" class="headerlink" title="18. 合并数据行"></a>18. 合并数据行</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data2 = &#123;<span class="string">&#x27;Key&#x27;</span>: [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>], <span class="string">&#x27;ef100&#x27;</span>: [<span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>], <span class="string">&#x27;ef_sub_100&#x27;</span>: [<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>]&#125;</span><br><span class="line">df2 = pd.DataFrame(data2)</span><br><span class="line">merged_df = pd.concat([df, df2])</span><br><span class="line"><span class="built_in">print</span>(merged_df)</span><br></pre></td></tr></table></figure>

<h4 id="19-插入数据行"><a href="#19-插入数据行" class="headerlink" title="19. 插入数据行"></a>19. 插入数据行</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 插入新行，需要全部补全数值</span></span><br><span class="line">df.loc[<span class="number">1.5</span>] = [<span class="string">&#x27;B&#x27;</span>, <span class="number">25</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]              <span class="comment"># 序号是1.5</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 插入新行，只指定部分列的值，其余列自动填充为 NaN</span></span><br><span class="line">df.loc[<span class="number">2.5</span>] = &#123;<span class="string">&#x27;Key&#x27;</span>: <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;ef100&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;ef_sub_100&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(df.tail())</span><br></pre></td></tr></table></figure>

<h4 id="20-删除数据行"><a href="#20-删除数据行" class="headerlink" title="20. 删除数据行"></a>20. 删除数据行</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = df.drop([<span class="number">1</span>, <span class="number">2</span>])                <span class="comment"># 删除第1,2行</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h4 id="21-填补列缺失值"><a href="#21-填补列缺失值" class="headerlink" title="21. 填补列缺失值"></a>21. 填补列缺失值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;melting&#x27;</span>] = df[<span class="string">&#x27;melting&#x27;</span>].fillna(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h4 id="22-去除重复值"><a href="#22-去除重复值" class="headerlink" title="22. 去除重复值"></a>22. 去除重复值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.loc[<span class="number">3.5</span>] = &#123;<span class="string">&#x27;Key&#x27;</span>: <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;ef100&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;ef_sub_100&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;melting&#x27;</span>: <span class="number">0</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(df.tail())</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = df.drop_duplicates()</span><br><span class="line"><span class="built_in">print</span>(df.tail())</span><br></pre></td></tr></table></figure>

<h4 id="23-数据透视表"><a href="#23-数据透视表" class="headerlink" title="23. 数据透视表"></a>23. 数据透视表</h4><p>NBA数据样例<br><a href="https://www.cnblogs.com/Yanjy-OnlyOne/p/11195621.html">https://www.cnblogs.com/Yanjy-OnlyOne/p/11195621.html</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pivot_table = pd.pivot_table(df, values=[<span class="string">&#x27;ef100&#x27;</span>,<span class="string">&#x27;ef_sub_100&#x27;</span>], index=[<span class="string">u&#x27;Key&#x27;</span>,<span class="string">u&#x27;melting&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(pivot_table)</span><br></pre></td></tr></table></figure>

<h4 id="24-数据转置"><a href="#24-数据转置" class="headerlink" title="24. 数据转置"></a>24. 数据转置</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">transposed_df = df.T</span><br><span class="line"><span class="built_in">print</span>(transposed_df)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="25-数据合并-按行"><a href="#25-数据合并-按行" class="headerlink" title="25. 数据合并(按行)"></a>25. 数据合并(按行)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df3 = pd.DataFrame(&#123;<span class="string">&#x27;Key&#x27;</span>: [<span class="string">&#x27;D&#x27;</span>], <span class="string">&#x27;melting&#x27;</span>: [<span class="number">300</span>], <span class="string">&#x27;ef100&#x27;</span>: [<span class="number">0</span>]&#125;)</span><br><span class="line"><span class="built_in">print</span>(df3)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">connected_df = pd.concat([df, df3])</span><br><span class="line"><span class="built_in">print</span>(connected_df)</span><br></pre></td></tr></table></figure>

<h4 id="26-数据行切片"><a href="#26-数据行切片" class="headerlink" title="26. 数据行切片"></a>26. 数据行切片</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sliced_df = df[<span class="number">3</span>:<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(sliced_df)</span><br></pre></td></tr></table></figure>

<h4 id="27-数据行迭代"><a href="#27-数据行迭代" class="headerlink" title="27. 数据行迭代"></a>27. 数据行迭代</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> index, row <span class="keyword">in</span> df.iterrows():</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br></pre></td></tr></table></figure>

<h4 id="28-数据过滤"><a href="#28-数据过滤" class="headerlink" title="28. 数据过滤"></a>28. 数据过滤</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">filtered_df = df[(df[<span class="string">&#x27;melting&#x27;</span>] &gt; <span class="number">1000</span>) &amp; (df[<span class="string">&#x27;ef_sub_100&#x27;</span>] &lt; <span class="number">0</span>)]</span><br><span class="line"><span class="built_in">print</span>(filtered_df)</span><br></pre></td></tr></table></figure>

<h4 id="29-数据替换"><a href="#29-数据替换" class="headerlink" title="29. 数据替换"></a>29. 数据替换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;Key&#x27;</span>] = df[<span class="string">&#x27;Key&#x27;</span>].replace(<span class="string">&#x27;A+&#x27;</span>, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h4 id="30-数据映射"><a href="#30-数据映射" class="headerlink" title="30. 数据映射"></a>30. 数据映射</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mapping = &#123;<span class="string">&#x27;A&#x27;</span>: <span class="string">&#x27;A++&#x27;</span>, <span class="string">&#x27;B&#x27;</span>: <span class="string">&#x27;B++&#x27;</span>&#125;</span><br><span class="line">df[<span class="string">&#x27;Key&#x27;</span>] = df[<span class="string">&#x27;Key&#x27;</span>].<span class="built_in">map</span>(mapping).fillna(df[<span class="string">&#x27;Key&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>加速Pandas，<a href="https://mp.weixin.qq.com/s/3eKWO4iT08mrNWfG3BGwSQ">https://mp.weixin.qq.com/s/3eKWO4iT08mrNWfG3BGwSQ</a></li>
<li><a href="https://mp.weixin.qq.com/s/FPkPUqxLXqBi8b_p30wlWg">https://mp.weixin.qq.com/s/FPkPUqxLXqBi8b_p30wlWg</a></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Theory</title>
    <url>/2024/07/21/theory/</url>
    <content><![CDATA[<p><strong><font size=6>Theory</font></strong><br><a href="http://cluster.qibebt.ac.cn/info/1189/1136.htm">d-band</a></p>
]]></content>
      <categories>
        <category>Learn</category>
      </categories>
      <tags>
        <tag>Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes of ASE</title>
    <url>/2024/07/29/notes-of-ase/</url>
    <content><![CDATA[<p><strong><font size=6>ASE 笔记</font></strong></p>
<h3 id="得到晶胞参数-方法一：Numpy"><a href="#得到晶胞参数-方法一：Numpy" class="headerlink" title="得到晶胞参数(方法一：Numpy)"></a>得到晶胞参数(方法一：Numpy)</h3><p>通过线性代数运算计算晶胞参数：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Numpy</span></span><br><span class="line"><span class="keyword">from</span> ase <span class="keyword">import</span> Atoms</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> ase.io <span class="keyword">import</span> read</span><br><span class="line"></span><br><span class="line">atoms = read(<span class="string">&#x27;POSCAR&#x27;</span>)</span><br><span class="line"><span class="comment"># 基矢</span></span><br><span class="line">cell = atoms.cell</span><br><span class="line">latticelength = np.dot(cell, cell.T).diagonal()</span><br><span class="line">latticelength = latticelength ** <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">cos_alpha = np.dot(cell[<span class="number">1</span>], cell[<span class="number">2</span>]) / (latticelength[<span class="number">1</span>] * latticelength[<span class="number">2</span>])</span><br><span class="line">cos_beta = np.dot(cell[<span class="number">0</span>], cell[<span class="number">2</span>]) / (latticelength[<span class="number">0</span>] * latticelength[<span class="number">2</span>])</span><br><span class="line">cos_gamma = np.dot(cell[<span class="number">0</span>], cell[<span class="number">1</span>]) / (latticelength[<span class="number">0</span>] * latticelength[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">alpha = np.degrees(np.arccos(cos_alpha))</span><br><span class="line">beta = np.degrees(np.arccos(cos_beta))</span><br><span class="line">gamma = np.degrees(np.arccos(cos_gamma))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="built_in">print</span>(latticelength[<span class="number">0</span>],latticelength[<span class="number">1</span>],latticelength[<span class="number">2</span>],alpha, beta, gamma)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>晶胞矩阵（Cell Matrix）</strong>：<br> 假设<code>cell</code>是一个 (3 \times 3) 的矩阵，表示晶胞的基矢量（a、b、c）：<br> [<br> \text{cell} &#x3D; \begin{pmatrix}<br> a_x &amp; a_y &amp; a_z \<br> b_x &amp; b_y &amp; b_z \<br> c_x &amp; c_y &amp; c_z \<br> \end{pmatrix}<br> ]<br> 这里，<code>a</code>、<code>b</code>、<code>c</code>是晶胞的基矢量，分别对应晶胞的三个边。</p>
</li>
<li><p><strong>点乘计算内积</strong>：<br> 使用<code>np.dot(cell, cell.T)</code>计算基矢量的内积：<br> [<br> \text{cell} \cdot \text{cell}^T &#x3D; \begin{pmatrix}<br> a_x &amp; a_y &amp; a_z \<br> b_x &amp; b_y &amp; b_z \<br> c_x &amp; c_y &amp; c_z \<br> \end{pmatrix} \cdot \begin{pmatrix}<br> a_x &amp; b_x &amp; c_x \<br> a_y &amp; b_y &amp; c_y \<br> a_z &amp; b_z &amp; c_z \<br> \end{pmatrix}<br> ]<br> 得到的结果是一个对称矩阵：<br> [<br> \text{dot_product} &#x3D; \begin{pmatrix}<br> a \cdot a &amp; a \cdot b &amp; a \cdot c \<br> b \cdot a &amp; b \cdot b &amp; b \cdot c \<br> c \cdot a &amp; c \cdot b &amp; c \cdot c \<br> \end{pmatrix}<br> ]</p>
</li>
<li><p><strong>提取对角线元素</strong>：<br> 使用<code>.diagonal()</code>提取对角线上的元素，这些元素分别是基矢量的内积：<br> [<br> \text{diagonal} &#x3D; \begin{pmatrix}<br> a \cdot a \<br> b \cdot b \<br> c \cdot c \<br> \end{pmatrix}<br> ]</p>
</li>
<li><p><strong>计算晶胞长度</strong>：<br> 对对角线元素开平方，得到晶胞的基矢量的长度（即晶胞参数）：<br> [<br> \text{latticelength} &#x3D; \begin{pmatrix}<br> \sqrt{a \cdot a} \<br> \sqrt{b \cdot b} \<br> \sqrt{c \cdot c} \<br> \end{pmatrix} &#x3D; \begin{pmatrix}<br> |a| \<br> |b| \<br> |c| \<br> \end{pmatrix}<br> ]</p>
</li>
<li><p><strong>得到晶胞的角度（α, β, γ）</strong><br> 晶胞的基矢量为：<br> [<br> \text{cell} &#x3D; \begin{pmatrix}<br> a_x &amp; a_y &amp; a_z \<br> b_x &amp; b_y &amp; b_z \<br> c_x &amp; c_y &amp; c_z \<br> \end{pmatrix}<br> ]<br> 晶胞的长度已经计算为：$a,b,c$</p>
<p> 晶胞的角度：</p>
</li>
</ol>
<p>[ \cos(\alpha) &#x3D; \frac{\mathbf{b} \cdot \mathbf{c}}{|b| \cdot |c|} ]<br>[ \cos(\beta) &#x3D; \frac{\mathbf{a} \cdot \mathbf{c}}{|a| \cdot |c|} ]<br>[ \cos(\gamma) &#x3D; \frac{\mathbf{a} \cdot \mathbf{b}}{|a| \cdot |b|} ]</p>
<h3 id="得到晶胞参数-方法二：ASE"><a href="#得到晶胞参数-方法二：ASE" class="headerlink" title="得到晶胞参数(方法二：ASE)"></a>得到晶胞参数(方法二：ASE)</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ASE</span></span><br><span class="line"><span class="keyword">from</span> ase <span class="keyword">import</span> Atoms</span><br><span class="line"><span class="keyword">from</span> ase.io <span class="keyword">import</span> read</span><br><span class="line"></span><br><span class="line">atoms = read(<span class="string">&#x27;POSCAR&#x27;</span>)</span><br><span class="line"><span class="comment"># atoms.cell.cellpar()方法</span></span><br><span class="line">length_a, length_b, length_c, angle_bc, angle_ac, angle_ab = atoms.cell.cellpar()</span><br><span class="line"><span class="built_in">print</span>(length_a, length_b, length_c, angle_bc, angle_ac, angle_ab)</span><br></pre></td></tr></table></figure>

<h3 id="恒电势方法的理解"><a href="#恒电势方法的理解" class="headerlink" title="恒电势方法的理解"></a>恒电势方法的理解</h3><p>参考 J. Am. Chem. Soc. 2022, 144, 39, 18144–18152<br><a href="https://www.bilibili.com/video/BV1zQ4y1P71F/?vd_source=dbd7edddb514b6a82b44048682e9c391">何政达——b站，恒电势</a></p>
<ol>
<li>公式1，改变电荷后的系统能量：<br>[ E &#x3D; E_{DFT}-\Delta n(V_{sol}+\Phi_q&#x2F;e) ]<br>$E_{DFT}$ 为 DFT 能量，e 为单位转化，Vsol 为体系的静电势，$\Phi_q$ 为体系相对于费米能级的功函数，$\Delta n$ 为电荷的变化量。</li>
<li>公式2，改变电荷后，系统的电势：<br>[ U_q(V&#x2F;SHE) &#x3D; -4.6,V-\Phi_q&#x2F;e ]</li>
<li>公式3，$E-U_q$的二次关系：<br>[ E(U_q) &#x3D; -\frac{1}{2}C(U_{q}-U_0)^2+E_0]<br>$U_q$为电势，$U_0$为零电荷电势(PZC)，C为系统电容，$E_0$为PAC下的能量。</li>
</ol>
<h4 id="得到对应电势的能量值"><a href="#得到对应电势的能量值" class="headerlink" title="得到对应电势的能量值"></a>得到对应电势的能量值</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># INCAR</span></span><br><span class="line">TAU = 0</span><br><span class="line">LAMBDA_D_K = 3</span><br><span class="line">LVHAR = T</span><br><span class="line">LSOL = T</span><br><span class="line">IDIPOL = 3</span><br><span class="line">NELECT = <span class="built_in">sum</span>(POTCAR) ± ne</span><br></pre></td></tr></table></figure>
<ol>
<li>${\Delta n}$：改变的 INCAR 参数 NELECT (Δn)</li>
<li>${\Phi_q}$：从 OUTCAR 中读取费米能级 E_fermi; 从 LOCPOT 中读取 vtot</li>
<li>${E_0}$：get energy from OUTCAR</li>
<li>SHE和RHE的转化<br>J.Am.Chem. Soc. 2024, 146,14954−14958<br><img src="/images/Notes-of-ASE-image.png" alt="SHE"></li>
</ol>
<p>电势校正<br>[E_{SHE} &#x3D; E_{measured}+E_{reference}]<br>[E_{RHE} &#x3D; E_{SHE}+0.0592pH ]</p>
]]></content>
      <categories>
        <category>ASE</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Notes of datastructure</title>
    <url>/2024/08/27/notes-of-datastructure/</url>
    <content><![CDATA[<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-image.png" alt="数据结构脑图"></p>
<h2 id="第一章：初识算法"><a href="#第一章：初识算法" class="headerlink" title="第一章：初识算法"></a>第一章：初识算法</h2><p><strong>算法（algorithm）数据结构（data structure）</strong></p>
<ol>
<li>生活中的二分法，排序，贪心算法：查字典，整理扑克，找零钱。</li>
<li>数据结构设计是一个充满权衡的过程。如果想在某方面取得提升，往往需要在另一方面作出妥协。</li>
<li>数据结构为算法提供了结构化存储的数据，以及操作数据的方法。<br>数据结构本身仅存储数据信息，结合算法才能解决特定问题。<br>算法通常可以基于不同的数据结构实现，但执行效率可能相差很大，选择合适的数据结构是关键。</li>
<li>在实际讨论时，我们通常会将“数据结构与算法”简称为“算法”。</li>
</ol>
<h2 id="第二章-复杂度分析"><a href="#第二章-复杂度分析" class="headerlink" title="第二章 复杂度分析"></a>第二章 复杂度分析</h2><p><strong>渐近复杂度分析（asymptotic complexity analysis）</strong></p>
<p><strong>时间复杂度（time complexity）</strong></p>
<ol>
<li>重复操作：<strong>迭代（iteration）递归（recursion）</strong></li>
<li>for 循环是最常见的迭代形式之一，适合在预先知道迭代次数时使用。while 循环比 for 循环的自由度更高。</li>
<li>每一次嵌套都是一次“升维”，将会使时间复杂度</li>
<li>迭代：“自下而上”地解决问题。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。</li>
<li>递归：“自上而下”地解决问题。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止（基本情况的解是已知的）。</li>
<li>递归通常比迭代更加耗费内存空间。因此递归通常比循环的时间效率更低。过深的递归可能导致栈溢出错误。适用于子问题分解，如树、图、分治、回溯等，代码结构简洁、清晰.</li>
<li>O(n) 时间复杂度分析统计的不是算法运行时间，而是算法运行时间随着数据量变大时的增长趋势。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-image-1.png" alt="时间复杂度"></li>
<li>指数阶增长非常迅速，在穷举法（暴力搜索、回溯等）中比较常见。对于数据规模较大的问题，指数阶是不可接受的，阶乘阶比指数阶增长得更快.通常需要使用动态规划或贪心算法等来解决。对数阶常出现于基于分治策略的算法中，体现了“一分为多”和“化繁为简”的算法思想。它增长缓慢，是仅次于常数阶的理想的时间复杂度。主流排序算法的时间复杂度通常为 O(nlogn) ，例如快速排序、归并排序、堆排序等。</li>
</ol>
<p><strong>空间复杂度（space complexity）</strong></p>
<ol>
<li>一般情况下，空间复杂度的统计范围是“暂存空间”加上“输出空间”<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-image-2.png" alt="空间复杂度"></li>
<li><code>hmap = dict[int, str]()</code> 这一行代码的意思是创建一个类型为 dict[int, str] 的空字典 </li>
<li>降低时间复杂度通常需要以提升空间复杂度为代价，反之亦然。我们将牺牲内存空间来提升算法运行速度的思路称为“以空间换时间”；反之，则称为“以时间换空间”。</li>
<li>函数（function）可以被独立执行，所有参数都以显式传递。方法（method）与一个对象关联，被隐式传递给调用它的对象，能够对类的实例中包含的数据进行操作。C 语言是过程式编程语言，没有面向对象的概念，所以只有函数。C++ 和 Python 既支持过程式编程（函数），也支持面向对象编程（方法）。</li>
</ol>
<h2 id="第三章-数据结构"><a href="#第三章-数据结构" class="headerlink" title="第三章 数据结构"></a>第三章 数据结构</h2><h3 id="3-1-数据结构"><a href="#3-1-数据结构" class="headerlink" title="3.1 数据结构"></a>3.1 数据结构</h3><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-image-4.png" alt="数据结构"></p>
<p><strong>内存资源</strong></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-image-5.png" alt="内存资源"></p>
<ol>
<li>物理结构反映了数据在计算机内存中的存储方式，可分为连续空间存储（数组）和分散空间存储（链表）</li>
<li> <img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-image-6.png" alt="存储方式"></li>
<li>所有数据结构都是基于数组、链表或二者的组合实现的。基于数组可实现：栈、队列、哈希表、树、堆、图、矩阵、张量（维度<br> 的数组）等。<br> 基于链表可实现：栈、队列、哈希表、树、堆、图等。</li>
<li>链表在初始化后，仍可以在程序运行过程中对其长度进行调整，因此也称“动态数据结构”。数组在初始化后长度不可变，因此也称“静态数据结构”。值得注意的是，数组可通过重新分配内存实现长度变化，从而具备一定的“动态性”。</li>
</ol>
<h3 id="3-2-基本数据类型"><a href="#3-2-基本数据类型" class="headerlink" title="3.2 基本数据类型"></a>3.2 基本数据类型</h3><ol>
<li>基本数据类型是 CPU 可以直接进行运算的类型，在算法中直接被使用，主要包括以下几种。<br>整数类型 byte、short、int、long 。<br>浮点数类型 float、double ，用于表示小数。<br>字符类型 char ，用于表示各种语言的字母、标点符号甚至表情符号等。<br>布尔类型 bool ，用于表示“是”与“否”判断。</li>
<li>基本数据类型以二进制的形式存储在计算机中。一个二进制位即为1比特。在绝大多数现代操作系统中，1字节（byte）由8比特（bit）组成。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-image-7.png" alt="JAVA空间占用"><br>在 Python 中，整数类型 int 可以是任意大小，只受限于可用内存；浮点数 float 是双精度 64 位；没有 char 类型，单个字符实际上是长度为 1 的字符串 str 。字符 char 的大小在 C 和 C++ 中为 1 字节，即使表示布尔量仅需 1 位，0&#x2F;1，它在内存中通常也存储为 1 字节。这是因为现代计算机 CPU 通常将 1 字节作为最小寻址内存单元。</li>
<li>基本数据类型提供了数据的“内容类型”，而数据结构提供了数据的“组织方式”。</li>
</ol>
<h3 id="3-3-数字编码"><a href="#3-3-数字编码" class="headerlink" title="3.3 数字编码*"></a>3.3 数字编码*</h3><h3 id="3-4-字符编码"><a href="#3-4-字符编码" class="headerlink" title="3.4 字符编码*"></a>3.4 字符编码*</h3><h2 id="第四章-数组与链表"><a href="#第四章-数组与链表" class="headerlink" title="第四章 数组与链表"></a>第四章 数组与链表</h2><h3 id="4-1-数组"><a href="#4-1-数组" class="headerlink" title="4.1 数组"></a>4.1 数组</h3><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-image-8.png" alt="数组储存"></p>
<ol>
<li>数组的索引本质上是内存地址的偏移量。</li>
<li>空间效率高：数组为数据分配了连续的内存块，无须额外的结构开销。插入与删除效率低：当数组中元素较多时，插入与删除操作需要移动大量的元素。</li>
<li>支持随机访问：数组允许在O(1)时间内访问任何元素。长度不可变：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。</li>
<li>缓存局部性：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。空间浪费：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。</li>
</ol>
<h3 id="4-2-链表"><a href="#4-2-链表" class="headerlink" title="4.2 链表"></a>4.2 链表</h3><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-image-9.png" alt="链表"></p>
<ol>
<li>链表节点 ListNode 除了包含值，还需额外保存一个引用（指针）。因此在相同数据量下，链表比数组占用更多的内存空间。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-image-10.png" alt="链表区别"></li>
<li>单向链表通常用于实现栈、队列、哈希表和图等数据结构。<br>栈与队列：当插入和删除操作都在链表的一端进行时，它表现的特性为先进后出，对应栈；当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现的特性为先进先出，对应队列。<br>哈希表：链式地址是解决哈希冲突的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。<br>图：邻接表是表示图的一种常用方式，其中图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。</li>
<li>双向链表：快速查找前一个和后一个元素<br>高级数据结构：比如在红黑树、B 树中，我们需要访问节点的父节点，这可以通过在节点中保存一个指向父节点的引用来实现，类似于双向链表。<br>浏览器历史：在网页浏览器中，当用户点击前进或后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。<br>LRU 算法：在缓存淘汰（LRU）算法中，我们需要快速找到最近最少使用的数据，以及支持快速添加和删除节点。这时候使用双向链表就非常合适。</li>
<li>环形链表常用于需要周期性操作的场景，比如操作系统的资源调度。</li>
</ol>
<h3 id="4-3-列表"><a href="#4-3-列表" class="headerlink" title="4.3 列表"></a>4.3 列表</h3><p>列表（list）是一个抽象的数据结构概念，它表示元素的有序集合，支持元素访问、修改、添加、删除和遍历等操作，无须使用者考虑容量限制的问题。列表可以基于链表或数组实现。</p>
<ol>
<li>当使用数组实现列表时，长度不可变的性质会导致列表的实用性降低。我们可以使用动态数组（dynamic array）来实现列表。</li>
<li>许多编程语言中的标准库提供的列表是基于动态数组实现的， Python 中的 list<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化列表</span></span><br><span class="line">nums: <span class="built_in">list</span>[<span class="built_in">int</span>] = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line"><span class="comment"># 清空列表</span></span><br><span class="line">nums.clear()</span><br><span class="line"><span class="comment"># 尾部添加元素1</span></span><br><span class="line">nums.append(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 在中间插入元素,在索引3处插入数字6</span></span><br><span class="line">nums.insert(<span class="number">3</span>, <span class="number">6</span>)  </span><br><span class="line"><span class="comment"># 删除元素</span></span><br><span class="line">nums.pop(<span class="number">3</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过索引遍历列表</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">    count += nums[i]</span><br><span class="line"><span class="comment"># 直接遍历列表元素</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    count += num</span><br><span class="line"><span class="comment"># 拼接两个列表</span></span><br><span class="line">nums1: <span class="built_in">list</span>[<span class="built_in">int</span>] = [<span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">9</span>]</span><br><span class="line">nums += nums1  <span class="comment"># 将列表 nums1 拼接到 nums 之后</span></span><br><span class="line"><span class="comment"># 排序列表</span></span><br><span class="line">nums.sort()  <span class="comment"># 排序后，列表元素从小到大排列</span></span><br></pre></td></tr></table></figure></li>
<li>列表实现：<a href="https://www.hello-algo.com/chapter_array_and_linkedlist/list/#432">https://www.hello-algo.com/chapter_array_and_linkedlist/list/#432</a></li>
</ol>
<h3 id="4-3-内存与缓存"><a href="#4-3-内存与缓存" class="headerlink" title="4.3 内存与缓存"></a>4.3 内存与缓存</h3><p>计算机中包括三种类型的存储设备：硬盘（hard disk）、内存（random-access memory, RAM）、缓存（cache memory）<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-image-11.png" alt="内存"></p>
<ol>
<li>硬盘用于长期存储大量数据，内存用于临时存储程序运行中正在处理的数据，而缓存则用于存储经常访问的数据和指令，以提高程序运行效率。三者共同协作，确保计算机系统高效运行。</li>
<li>在程序运行时，数据会从硬盘中被读取到内存中，供 CPU 计算使用。缓存可以看作 CPU 的一部分，它通过智能地从内存加载数据，给 CPU 提供高速的数据读取，从而显著提升程序的执行效率，减少对较慢的内存的依赖。</li>
</ol>
<h2 id="第五章-栈与队列"><a href="#第五章-栈与队列" class="headerlink" title="第五章 栈与队列"></a>第五章 栈与队列</h2><h3 id="5-1-栈"><a href="#5-1-栈" class="headerlink" title="5.1 栈"></a>5.1 栈</h3><p>栈（stack）：先入后出；类比为叠猫猫<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-image-13.png" alt="栈的操作"></p>
<ol>
<li>Python 没有内置的栈类</li>
<li>只能在栈顶添加或删除元素，因此栈可以视为一种受限制的数组或链表<br><strong>&lt;基于链表和数组实现的栈.ipynb&gt;</strong></li>
<li>在基于数组的实现中，入栈和出栈操作都在预先分配好的连续内存中进行，具有很好的缓存本地性，因此效率较高。然而，如果入栈时超出数组容量，会触发扩容机制，导致该次入栈操作的时间复杂度变为O(n)。</li>
<li>在基于链表的实现中，链表的扩容非常灵活，不存在上述数组扩容时效率降低的问题。但是，入栈操作需要初始化节点对象并修改指针，因此效率相对较低。不过，如果入栈元素本身就是节点对象，那么可以省去初始化步骤，从而提高效率。基于链表实现的栈可以提供更加稳定的效率表现。</li>
<li>在初始化列表时，系统会为列表分配“初始容量”，该容量可能超出实际需求；并且，扩容机制通常是按照特定倍率（例如 2 倍）进行扩容的，扩容后的容量也可能超出实际需求。因此，基于数组实现的栈可能造成一定的空间浪费。然而，由于链表节点需要额外存储指针，因此链表节点占用的空间相对较大。</li>
<li>浏览器中的后退与前进、软件中的撤销与反撤销。程序内存管理。每次调用函数时，系统都会在栈顶添加一个栈帧，用于记录函数的上下文信息。</li>
</ol>
<h3 id="5-2-队列"><a href="#5-2-队列" class="headerlink" title="5.2 队列"></a>5.2 队列</h3><p>队列（queue）先入先出;猫猫排队<br><strong>&lt;基于链表和数组实现的队列.ipynb&gt;</strong><br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-image-14.png" alt="队列"></p>
<ol>
<li>淘宝订单。购物者下单后，订单将加入队列中，系统随后会根据顺序处理队列中的订单。在双十一期间，短时间内会产生海量订单，高并发成为工程师们需要重点攻克的问题。</li>
<li>各类待办事项。任何需要实现“先来后到”功能的场景，例如打印机的任务队列、餐厅的出餐队列等，队列在这些场景中可以有效地维护处理顺序。</li>
<li>在队列中，我们仅能删除头部元素或在尾部添加元素。如图 5-7 所示，双向队列（double-ended queue）提供了更高的灵活性，允许在头部和尾部执行元素的添加或删除操作。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-image-15.png" alt="双向队列"></li>
<li>双向队列兼具栈与队列的逻辑，因此它可以实现这两者的所有应用场景，同时提供更高的自由度。</li>
<li>软件的“撤销”功能通常使用栈来实现：系统将每次更改操作 push 到栈中，然后通过 pop 实现撤销。然而，考虑到系统资源的限制，软件通常会限制撤销的步数。当栈的长度超过时，软件需要在栈底（队首）执行删除操作。但栈无法实现该功能，此时就需要使用双向队列来替代栈。“撤销”的核心逻辑仍然遵循栈的先入后出原则，只是双向队列能够更加灵活地实现一些额外逻辑。<br><strong>6. 使用两个栈，栈 A 用于撤销，栈 B 用于反撤销。</strong><br>每当用户执行一个操作，将这个操作压入栈 A ，并清空栈 B 。<br>当用户执行“撤销”时，从栈 A 中弹出最近的操作，并将其压入栈 B 。<br>当用户执行“反撤销”时，从栈 B 中弹出最近的操作，并将其压入栈 A 。</li>
</ol>
<h2 id="第六章-哈希表"><a href="#第六章-哈希表" class="headerlink" title="第六章 哈希表"></a>第六章 哈希表</h2><p>哈希表（hash table），又称散列表。它通过建立键 key 与值 value 之间的映射，实现高效的元素查询。<br><img src="/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-image-16.png" alt="查询效率"><br>在哈希表中进行增删查改的时间复杂度都是O(1)，非常高效。</p>
<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><p>增删查改</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化哈希表</span></span><br><span class="line">hmap: <span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line"><span class="comment"># 在哈希表中添加键值对 (key, value)</span></span><br><span class="line">hmap[<span class="number">10583</span>] = <span class="string">&quot;小鸭&quot;</span></span><br><span class="line"><span class="comment"># 向哈希表中输入键 key ，得到值 value</span></span><br><span class="line">name: <span class="built_in">str</span> = hmap[<span class="number">15937</span>]</span><br><span class="line"><span class="comment"># 在哈希表中删除键值对 (key, value)</span></span><br><span class="line">hmap.pop(<span class="number">10583</span>)</span><br></pre></td></tr></table></figure>
<p>遍历操作</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 遍历键值对 key-&gt;value</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> hmap.items():</span><br><span class="line">    <span class="built_in">print</span>(key, <span class="string">&quot;-&gt;&quot;</span>, value)</span><br><span class="line"><span class="comment"># 单独遍历键 key</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> hmap.keys():</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br><span class="line"><span class="comment"># 单独遍历值 value</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> hmap.values():</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure>
<p>&lt;哈希表的简单实现.ipynb&gt;<br><img src="/images/Data_structures-image.png" alt="hashmap"></p>
<h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突*"></a>哈希冲突*</h3><ol start="0">
<li>通常情况下哈希函数的输入空间远大于输出空间，因此理论上哈希冲突是不可避免的。比如，输入空间为全体整数，输出空间为数组容量大小，则必然有多个整数映射至同一桶索引。</li>
<li>哈希表容量n越大，多个 key 被分配到同一个桶中的概率就越低，冲突就越少。因此，我们可以通过扩容哈希表来减少哈希冲突。</li>
<li>类似于数组扩容，哈希表扩容需将所有键值对从原哈希表迁移至新哈希表，非常耗时；并且由于哈希表容量 capacity 改变，我们需要通过哈希函数来重新计算所有键值对的存储位置，这进一步增加了扩容过程的计算开销。为此，编程语言通常会预留足够大的哈希表容量，防止频繁扩容。</li>
<li>负载因子（load factor）是哈希表的元素数量除以桶数量，用于衡量哈希冲突的严重程度。</li>
<li>改良哈希表数据结构，使得哈希表可以在出现哈希冲突时正常工作。仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。哈希表的结构改良方法主要包括“链式地址”和“开放寻址”。</li>
</ol>
<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树（binary tree）是一种非线性数据结构。</p>
<p>二叉树的基本单元是节点，每个节点包含值、左子节点引用和右子节点引用。</p>
]]></content>
      <tags>
        <tag>computer science</tag>
      </tags>
  </entry>
  <entry>
    <title>Scripts of KGZ</title>
    <url>/2024/12/29/scripts-of-kgz/</url>
    <content><![CDATA[<p><strong><font size=6>Scripts of KGZ</font></strong></p>
<p>本教程基于 HPC of zhenggroup 集群环境<br><a href="https://github.com/LU-SONG/Computational-Chemistry/blob/main/scripts/scripts.md">https://github.com/LU-SONG/Computational-Chemistry/blob/main/scripts/scripts.md</a></p>
<hr>
<h2 id="python脚本-2024"><a href="#python脚本-2024" class="headerlink" title="python脚本(2024)"></a>python脚本(2024)</h2><table>
<thead>
<tr>
<th>-脚本名称-</th>
<th>-功能-</th>
<th>-使用方法-</th>
</tr>
</thead>
<tbody><tr>
<td>add_H2O.py</td>
<td>Add H2O to the slab.</td>
<td>python3 add_H2O.py</td>
</tr>
<tr>
<td>add_site_ads.py</td>
<td>添加中间体的吸附位点，top&#x2F;bridge&#x2F;hollow</td>
<td>python3 add_site_ads.py -h</td>
</tr>
<tr>
<td>bader2pqr.py</td>
<td>将bader转化为pqr格式，可视化</td>
<td>python3 bader2pqr.py</td>
</tr>
<tr>
<td>ck-multi.py</td>
<td>查看串行脚本的运行情况</td>
<td>python3 ck-multi.py multi_job.pbs</td>
</tr>
<tr>
<td>d-band.py</td>
<td>d带中心分析（需要先做完pdos计算）</td>
<td>python3 d-band.py</td>
</tr>
<tr>
<td>plot_pdos.py</td>
<td>plot the projected density of states (PDOS) from data and save the figure.</td>
<td>python3 plot_pdos.py</td>
</tr>
<tr>
<td>eps2jpg.py</td>
<td>convert an EPS file to a high-resolution PNG image.</td>
<td>python eps2png.py</td>
</tr>
<tr>
<td>fix_slab.py</td>
<td>fix the slab in POSCAR.</td>
<td>python3 fix_slab.py -The number of atoms you want to fix.</td>
</tr>
<tr>
<td>get_cp.py</td>
<td>data to a quadratic polynomial and calculate related statistical quantities.</td>
<td>python get_cp.py</td>
</tr>
<tr>
<td>get_db.py</td>
<td>store the calculated crystal structure data into a SQLite database.</td>
<td>python get_db.py</td>
</tr>
<tr>
<td>get_dimer.py</td>
<td>Extract vibrational mode information from a OUTCAR file and add it to a new POSCAR_dimer file for dimer (two-molecule) calculations.</td>
<td>python get_dimer.py</td>
</tr>
<tr>
<td>neighbor_multi_atoms.py</td>
<td>Calculate and analyze the neighboring atoms of a specified atom in the crystal structure , generate a Markdown formatted table to display the neighboring atoms.</td>
<td>python neighbor_multi_atoms.py -filename -central_atom_index -cutoff</td>
</tr>
<tr>
<td>out_view.py</td>
<td>Read the crystal structure data from the CONTCAR file and use the matplotlib library to generate top views and two side views (XZ and YZ planes) of the atomic structure.</td>
<td>python out_view.py</td>
</tr>
<tr>
<td>pos2arc.py</td>
<td>transfer POSCAR to .arc or transfer .arc to POSCAR.</td>
<td>python pos2arc.py -pos2arc&#x2F;-arc2pos</td>
</tr>
<tr>
<td>RDF.py</td>
<td>Read data from a Radial Distribution Function (RDF) data file, calculate the average RDF, and plot the RDF graph.</td>
<td>python RDF.py</td>
</tr>
<tr>
<td>revise_boundary_length.py</td>
<td>Revise boundry atoms view.</td>
<td>Python revise_boundary_length.py filename</td>
</tr>
<tr>
<td>sort_poscar_atoms.py</td>
<td>sort the same elements in POSCAR.</td>
<td>python sort_poscar_atoms.py</td>
</tr>
<tr>
<td>vector2ort.py</td>
<td>Converted cells into orthorhombic system</td>
<td>python vector2ort.py</td>
</tr>
</tbody></table>
<hr>
<h2 id="shell脚本（2024）"><a href="#shell脚本（2024）" class="headerlink" title="shell脚本（2024）"></a>shell脚本（2024）</h2><table>
<thead>
<tr>
<th>-脚本名称-</th>
<th>-功能-</th>
<th>-使用方法-</th>
</tr>
</thead>
<tbody><tr>
<td>bader.sh</td>
<td>Perform Bader charge analysis of the charge density around atoms to obtain the valence electron count of the atoms.</td>
<td>bader.sh</td>
</tr>
<tr>
<td>checkinput.sh</td>
<td>get energy and force from OUTCAR&#x2F;OSZICAR</td>
<td>checkinput.sh</td>
</tr>
<tr>
<td>checkpospot.sh</td>
<td>Check for VASP input files POSCAR and POTCAR in the current directory and its subdirectories.</td>
<td>checkpospot.sh</td>
</tr>
<tr>
<td>correct_H.sh</td>
<td>Traverse the current directory and its subdirectories, looking for VASP calculation result files OUTCAR, and use the vaspkit tool to calculate the thermodynamic correction value (deltaG).</td>
<td>correct_H.sh</td>
</tr>
<tr>
<td>correct-cp2k.sh</td>
<td>Traverse the current directory and its subdirectories, looking for CP2K calculation result files cp2k.out, and use a tool called Shermo to calculate the thermodynamic correction value (deltaG).</td>
<td>correct-cp2k.sh</td>
</tr>
<tr>
<td>CP2K_OUTPUT_save.sh</td>
<td>Extract the execution time and computation duration from a CP2K calculation result file named cp2k.out, then create a new backup folder based on this information, and copy the relevant CP2K input and output files into this folder.</td>
<td>CP2K_OUTPUT_save.sh</td>
</tr>
<tr>
<td>fix_all_slab.sh</td>
<td>Batch execute the Python script fix_slab.py.</td>
<td>fix_all_slab.sh</td>
</tr>
<tr>
<td>g16_out2gjf.sh</td>
<td>Convert geometry (final, input orientation) in all Gaussian .out files in current folder to .gjf file by Multiwfn</td>
<td>g16_out2gjf.sh</td>
</tr>
<tr>
<td>get_force.sh</td>
<td>eliminate forces of fixed atoms</td>
<td>get_force.sh -fix_value</td>
</tr>
<tr>
<td>get_hol_ele_cub.sh</td>
<td>generate three different cube files (hole.cub, electron.cub, and CDD.cub), and rename them to include a serial number in the file name.</td>
<td>get_hol_ele_cub.sh</td>
</tr>
<tr>
<td>incar_modi.sh</td>
<td>Find all lines containing IDIPOL&#x3D;3 in the INCAR file and comment out these lines.</td>
<td>incar_modi.sh</td>
</tr>
<tr>
<td>kpoints.sh</td>
<td>To generate KPOINTS file</td>
<td>kpoints.sh  3 3 1</td>
</tr>
<tr>
<td>mk_pwdfreq.sh</td>
<td>Prepare and modify input files for VASP calculations.</td>
<td>mk_pwdfreq.sh</td>
</tr>
<tr>
<td>mkfreq.sh</td>
<td>Prepare and modify input files for VASP calculations, and organize all related files into a temporary directory.</td>
<td>mkfreq.sh</td>
</tr>
<tr>
<td>mk-pbs.sh</td>
<td>Generate job submission scripts (sub.pbs) for different computational tasks, which are used to submit jobs on high-performance computing clusters.</td>
<td>mk-pbs.sh</td>
</tr>
<tr>
<td>multi_qsub48.sh</td>
<td>Batch modify the NCORE parameter in the INCAR files of all subdirectories under the current directory, setting it to 12, then copy a PBS job submission script named multisub48.pbs to the current directory, and submit the script using the qsub command.</td>
<td>multi_qsub48.sh</td>
</tr>
<tr>
<td>multi_qsub56.sh</td>
<td>Batch modify the NCORE parameter in the INCAR files of all subdirectories under the current directory, setting it to 14, then copy a PBS job submission script named multisub56.pbs to the current directory, and submit the script using the qsub command.</td>
<td>multi_qsub56.sh</td>
</tr>
<tr>
<td>pos2potall.sh</td>
<td>Batch generate POTCAR in all subdirectories</td>
<td>pos2potall.sh</td>
</tr>
<tr>
<td>potall.sh</td>
<td>Batch generate POTCAR in all subdirectories</td>
<td>potall.sh</td>
</tr>
<tr>
<td>potcar.sh</td>
<td>Rename the old POTCAR to old-POTCAR, and look for POTCAR files matching the command-line arguments from the specified pseudopotential repository path, then concatenate them into the POTCAR file in the current directory.</td>
<td>potcar Cu C H O</td>
</tr>
<tr>
<td>q48.sh</td>
<td>Check the NCORE parameter in INCAR and submit the 48kgz.pbs job script to the job scheduling system.</td>
<td>q48.sh</td>
</tr>
<tr>
<td>q56.sh</td>
<td>Check the NCORE parameter in INCAR and submit the 56kgz.pbs job script to the job scheduling system.</td>
<td>q56.sh</td>
</tr>
<tr>
<td>qsuball.sh</td>
<td>Iterate through all subdirectories in the current directory and execute the qsub command in each subdirectory to submit all .pbs files as jobs.</td>
<td>qsuball.sh</td>
</tr>
<tr>
<td>save+zip_all_OUTPUT.sh</td>
<td>Copy the VASP calculation related files (CONTCAR, INCAR, KPOINTS, OSZICAR, OUTCAR, POTCAR) from all the first-level subdirectories in the current directory to a temporary directory, then pack these files into a ZIP file, and finally delete the temporary directory.</td>
<td>save+zip_all_OUTPUT.sh</td>
</tr>
<tr>
<td>save+zip_OUTPUT.sh</td>
<td>Copy the CONTCAR files from all the first-level subdirectories in the current directory to a temporary directory, then pack these files into a ZIP file, and finally delete the temporary directory.</td>
<td>save+zip_OUTPUT.sh</td>
</tr>
<tr>
<td>scpfiles2cfff.sh</td>
<td>Use the scp command via SSH to copy files or directories from the local machine to a remote server, and handle any interactive prompts that may appear.</td>
<td>scpfiles2cfff.sh -path</td>
</tr>
<tr>
<td>ta.sh</td>
<td>Get energy and force from OUTCAR&#x2F;OSZICAR</td>
<td>ta.sh or ta.sh -g</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>DFT</category>
      </categories>
      <tags>
        <tag>vasp</tag>
        <tag>scripts</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP of Gaussian</title>
    <url>/2024/05/14/vmd-esp/</url>
    <content><![CDATA[<ol>
<li><code>Multiwfn</code> 12 0<br><img src="/images/VMD_ESP-image.png" alt="文件导出"></li>
<li>启动VMD，然后把furan.pdb、surfanalysis.pdb和vtx.pdb按顺序依次拖动到VMD主窗口里</li>
<li>Display-Depth Cueing 去掉，防止模糊</li>
<li>进入Graphics-Colors，选Display-Background-White将背景改为白色，并且在此界面的Color-Scale标签页里选择BWR，使分子表面的色彩根据数值范围由小到大以 蓝-白-红 的方式变化。选Display-Axes-Off不让坐标轴显示出来。</li>
<li>在Graphics-Representations-Selected Molecule一栏里选择furan.pdb，Drawing Method选Licorice，Bond Radius减小到0.1。</li>
<li>(2)在Selected Molecule一栏里选择vtx.pdb，Drawing Method选Points，Size设为25（设多大合决于视角的远近，在当前视角下应当让size恰好足够大，使分子表面上的顶点紧密相连，不留明显空隙），Coloring Method选Beta（根据pdb文件里B因子那一列的数据，此例即静电势数值进行填色），在Trajectory标签页里将Color Scale Data Range填上-22和22并点击Set，代表色彩刻度设为-22~20kcal&#x2F;mol（其实此例用默认的色彩刻度范围就可以，这里只是为了取个整）。现在分子表面填色图就出现了。越蓝的区域静电势越负，越红的区域越正，白色区域的静电势数值在0附近。</li>
<li>之后给图上加上色彩刻度轴。选Extensions-Visualization-Color Scale Bar，Color bar width设为0.08，Display title选on并且将Color bar title里写上ESP (kcal&#x2F;mol)，Minimum和Maximum scale value分别填-22和22，Number of axis labels输入10，Color labels选Black，Label format选Decimal。然后点Draw Color Scale Bar按钮，色彩刻度就出现在画面中了，并且VMD Main窗口中多出了一个名为Color Scale Bar的一项。然后调整它的大小和位置，即双击VMD Main窗口中Color Scale Bar那一项当中的F标签使之变为红色（即不让色彩刻度轴在画面中的位置冻结），而双击其它项目的F标签使它们的F变为黑色（让它们的位置冻结住）。然后点击VMD的OpenGL图形窗口激活之，按t键进入平移模式，然后拖动鼠标将色彩刻度轴放置到合适位置，并且用鼠标滚轮调整它的大小。调合适之后再按r键恢复旋转视角模式，并且在VMD Main里将Color Scale Bar那一项的F重新双击成黑色，而其它三项的F重新双击为红色。</li>
</ol>
]]></content>
      <categories>
        <category>DFT</category>
      </categories>
      <tags>
        <tag>gaussian</tag>
      </tags>
  </entry>
  <entry>
    <title>Single-point-energy-of-VASP</title>
    <url>/2024/06/03/single-point-energy-of-vasp/</url>
    <content><![CDATA[<p><strong><font size=6>Single point energy of VASP</font></strong><br>bader&#x2F;LELF</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">LAECHG = T</span><br><span class="line">LCHARG = T</span><br><span class="line">LELF = T</span><br><span class="line">NSW = 1</span><br></pre></td></tr></table></figure>
<p>bader.sh<br>get_bader.py</p>
<p>pdos</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LWAVE = T</span><br><span class="line">LORBIT = 11</span><br><span class="line">NSW = 1</span><br><span class="line">ISMEAR = -5</span><br></pre></td></tr></table></figure>
<p>get_pdos_selected_atoms_and_orbitals.sh O 2p<br>K点放大到2倍</p>
]]></content>
      <categories>
        <category>DFT</category>
      </categories>
      <tags>
        <tag>vasp</tag>
      </tags>
  </entry>
</search>
